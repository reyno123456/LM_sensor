///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.30.0.50166/W32 for Atmel AVR   11/Dec/2009  23:20:57 /
// Copyright 1996-2009 IAR Systems AB.                                        /
//                                                                            /
//    Source file  =  D:\avr\LM_Finial_Test\function_service.c                /
//    Command line =  D:\avr\LM_Finial_Test\function_service.c --cpu=m644p    /
//                    -ms -o D:\avr\LM_Finial_Test\Release\Obj\ -D NDEBUG -D  /
//                    LM018 -D FINAL_VERSION2 -lCN                            /
//                    D:\avr\LM_Finial_Test\Release\List\ -lA                 /
//                    D:\avr\LM_Finial_Test\Release\List\ --diag_suppress     /
//                    Pa082,Pe167,Pe186 --initializers_in_flash -z6           /
//                    --no_inline --no_cross_call --no_tbaa                   /
//                    -DENABLE_BIT_DEFINITIONS -e -I "C:\Program Files\IAR    /
//                    Systems\Embedded Workbench 5.3\avr\INC\" -I             /
//                    "C:\Program Files\IAR Systems\Embedded Workbench        /
//                    5.3\avr\INC\CLIB\" --eeprom_size 2048                   /
//    List file    =  D:\avr\LM_Finial_Test\Release\List\function_service.s90 /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME function_service

        RTMODEL "__64bit_doubles", "disabled"
        RTMODEL "__cpu", "3"
        RTMODEL "__cpu_name", "ATmega644P"
        RTMODEL "__enhanced_core", "enabled"
        RTMODEL "__has_elpm", "false"
        RTMODEL "__memory_model", "2"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B12_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B8_L09
        EXTERN ?F2SL_L04
        EXTERN ?F_CMP_LT_L04
        EXTERN ?F_MUL_L04
        EXTERN ?L_EC_MUL_L03
        EXTERN ?PROLOGUE12_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE8_L09
        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R11_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?SV_SWITCH_L06
        EXTERN ?S_EC_MUL_L02
        EXTERN ?UL2F_L04
        EXTERN ?UL_DIVMOD_L03
        EXTERN __eeget8_16

        PUBLIC Call_detect_delay
        FUNCTION Call_detect_delay,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Check_SCS_received
        FUNCTION Check_SCS_received,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Delay_Alert
        FUNCTION Delay_Alert,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Function_KO119
        FUNCTION Function_KO119,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Function_KO128
        FUNCTION Function_KO128,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 4, STACK
        PUBLIC Function_KO164
        FUNCTION Function_KO164,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 4, STACK
        PUBLIC Function_KO165
        FUNCTION Function_KO165,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Function_KO166
        FUNCTION Function_KO166,0203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Function_KO168
        FUNCTION Function_KO168,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Function_LM_GR
        FUNCTION Function_LM_GR,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC GS_presence_send
        FUNCTION GS_presence_send,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC OFF_takeline
        FUNCTION OFF_takeline,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC ON_takeline
        FUNCTION ON_takeline,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Start_Time_Delay
        FUNCTION Start_Time_Delay,0203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC Stop_allTimer
        FUNCTION Stop_allTimer,0203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC WT_20s_detect
        FUNCTION WT_20s_detect,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC _Initial_state
        FUNCTION _Initial_state,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 4, STACK
        PUBLIC _Maintain_state
        FUNCTION _Maintain_state,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC _ReTrigger_State
        FUNCTION _ReTrigger_State,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC _Standby_state
        FUNCTION _Standby_state,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC check_frame_received_maintain
        FUNCTION check_frame_received_maintain,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC frame_OFF_send
        FUNCTION frame_OFF_send,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC frame_ON_send
        FUNCTION frame_ON_send,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC frame_pp_on_off
        FUNCTION frame_pp_on_off,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC frame_presence
        FUNCTION frame_presence,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC function_check_status
        FUNCTION function_check_status,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC function_service
        FUNCTION function_service,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC function_service_init
        FUNCTION function_service_init,021203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 4, STACK
        PUBLIC occupancy_detect
        FUNCTION occupancy_detect,0a1203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC timer_5m_initial
        FUNCTION timer_5m_initial,0203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        PUBLIC timer_interval_initial
        FUNCTION timer_interval_initial,0203H
        ARGFRAME RSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_Y Y DATA
        CFI StackFrame CFA_SP SP DATA
        CFI VirtualResource ?RetPad:1, ?RetHigh:8, ?RetLow:8, ?Ret:17
        CFI Resource R0:8, R1:8, R2:8, R3:8, R4:8, R5:8, R6:8, R7:8, R8:8, R9:8
        CFI Resource R10:8, R11:8, R12:8, R13:8, R14:8, R15:8, R16:8, R17:8
        CFI Resource R18:8, R19:8, R20:8, R21:8, R22:8, R23:8, R24:8, R25:8
        CFI Resource R26:8, R27:8, R28:8, R29:8, R30:8, R31:8
        CFI Resource ?RetHighByteMask:8, SP:16, SPH:8, SPL:8, Y:16
        CFI ResourceParts ?Ret ?RetHigh, ?RetLow, ?RetPad
        CFI ResourceParts SP SPH, SPL
        CFI ResourceParts Y R29, R28
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign 1
        CFI ReturnAddress ?Ret CODE
        CFI CFA_Y Y+0
        CFI CFA_SP SP+2
        CFI ?RetPad 0
        CFI ?RetHigh and(load(1, DATA, sub(CFA_SP, 1)), ?RetHighByteMask)
        CFI ?RetLow Frame(CFA_SP, 0)
        CFI ?Ret Concat
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 SameValue
        CFI R13 SameValue
        CFI R14 SameValue
        CFI R15 SameValue
        CFI R16 Undefined
        CFI R17 Undefined
        CFI R18 Undefined
        CFI R19 Undefined
        CFI R20 Undefined
        CFI R21 Undefined
        CFI R22 Undefined
        CFI R23 Undefined
        CFI R24 SameValue
        CFI R25 SameValue
        CFI R26 SameValue
        CFI R27 SameValue
        CFI R28 Undefined
        CFI R29 Undefined
        CFI R30 Undefined
        CFI R31 Undefined
        CFI ?RetHighByteMask SameValue
        CFI SPH Undefined
        CFI SPL Undefined
        CFI EndCommon cfiCommon0
        
        EXTERN CharToStr
        FUNCTION CharToStr,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN send_frame_pp_broad
        FUNCTION send_frame_pp_broad,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN Mode_frame_GR
        FUNCTION Mode_frame_GR,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN regulation_timer_initial
        FUNCTION regulation_timer_initial,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN dimmer_command
        FUNCTION dimmer_command,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN buzzer_ms
        FUNCTION buzzer_ms,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN frame_M2_answer
        FUNCTION frame_M2_answer,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN DLL_setpoint
        FUNCTION DLL_setpoint,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN motion_detect
        FUNCTION motion_detect,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN Dled_light_on_ms
        FUNCTION Dled_light_on_ms,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN Light_regulation
        FUNCTION Light_regulation,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN read_adc10bit
        FUNCTION read_adc10bit,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN configuration_answer_frame
        FUNCTION configuration_answer_frame,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN relay_timer_initial
        FUNCTION relay_timer_initial,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN get_dl_level
        FUNCTION get_dl_level,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN daylight_service
        FUNCTION daylight_service,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN timer0_enable
        FUNCTION timer0_enable,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN ultWarmUpEvents
        FUNCTION ultWarmUpEvents,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN daylight_set_init
        FUNCTION daylight_set_init,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN StrToChar
        FUNCTION StrToChar,0202H
        ARGFRAME RSTACK, 0, STACK
        EXTERN DLL
        EXTERN Delay_Time_set
        EXTERN First_detection_enable
        EXTERN KO
        EXTERN KO_conf
        EXTERN M2_timer
        EXTERN PIR_detection_en
        EXTERN SCS_received
        EXTERN Sensor_mode
        EXTERN Time_delay
        EXTERN US_detection_en
        EXTERN Walk_Through_flag
        EXTERN eep_M2_hour
        EXTERN eep_M2_min
        EXTERN eep_M2_sec
        EXTERN flags
        EXTERN g_slope
        EXTERN motion_resutl
        EXTERN motion_total
        EXTERN product_information
        EXTERN set_point

// D:\avr\LM_Finial_Test\function_service.c
//    1 // Function_KO168.c
//    2 
//    3 #include <ioavr.h>
//    4 #include <inavr.h>
//    5 #include "IR.h"
//    6 #include "PIR.h"
//    7 #include "US.h"
//    8 #include "usart.h"
//    9 #include "board.h"
//   10 #include "moudle_SCS.h"
//   11 #include "application.h"
//   12 #include "configuration.h"
//   13 #include "decode_scs.h"
//   14 #include "decode_scs_next.h"
//   15 #include "global_variable.h"
//   16 #include "function_service.h"
//   17 
//   18 //******************************************************************************
//   19 // 	send frame presence
//   20 //******************************************************************************
//   21 //Mode_frame_GR(KO_conf.GR,nopre);
//   22 //GS_presence_send();
//   23 //frame_presence('1') pp mode
//   24 

        RSEG CODE:CODE:NOROOT(1)
//   25 void frame_presence(unsigned char arg)
frame_presence:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function frame_presence
//   26 {
        FUNCALL frame_presence, CharToStr
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_presence, send_frame_pp_broad
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R24
        CFI R24 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        SBIW    R29:R28, 11
        CFI CFA_Y Y+12
        MOV     R24, R16
//   27 		// B8 APL 1D 00
//   28 		unsigned char TX_buffer[8];
//   29     unsigned char buffer[3];
//   30 		
//   31 		TX_buffer[0] = 'B';
        LDI     R16, 66
        STD     Y+3, R16
//   32 		TX_buffer[1] = '8';
        LDI     R16, 56
        STD     Y+4, R16
//   33     //TX_buffer[2] = Configurators.A;
//   34     //TX_buffer[3] = Configurators.PL;
//   35 		CharToStr(KO_conf.DesAdd,buffer);  //reyno 0619
        MOVW    R19:R18, R29:R28
        LDS     R16, (KO_conf + 2)
        CALL    CharToStr
//   36 		TX_buffer[2] = buffer[0];
        LD      R16, Y
        STD     Y+5, R16
//   37 		TX_buffer[3] = buffer[1];
        LDD     R16, Y+1
        STD     Y+6, R16
//   38 		TX_buffer[4] = '1';
        LDI     R16, 49
        STD     Y+7, R16
//   39 		TX_buffer[5] = 'D';
        LDI     R16, 68
        STD     Y+8, R16
//   40 		TX_buffer[6] = '0';
        LDI     R16, 48
        STD     Y+9, R16
//   41 		TX_buffer[7] = arg;
        STD     Y+10, R24
//   42 		send_frame_pp_broad(TX_buffer, TRANS_DELAY);
        LDI     R18, 50
        LDI     R19, 0
        MOVW    R17:R16, R29:R28
        SUBI    R16, 253
        SBCI    R17, 255
        CALL    send_frame_pp_broad
//   43 
//   44 }
        ADIW    R29:R28, 11
        CFI CFA_Y Y+1
        LD      R24, Y+
        CFI R24 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock0
//   45 
//   46 //******************************************************************************
//   47 // 	send frame no presence + OFF
//   48 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//   49 void frame_pp_on_off( unsigned char command )
frame_pp_on_off:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function frame_pp_on_off
//   50 {
        FUNCALL frame_pp_on_off, CharToStr
        LOCFRAME CSTACK, 14, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_pp_on_off, CharToStr
        LOCFRAME CSTACK, 14, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_pp_on_off, send_frame_pp_broad
        LOCFRAME CSTACK, 14, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        CALL    ?PROLOGUE4_L09
        CFI R27 Frame(CFA_Y, -1)
        CFI R26 Frame(CFA_Y, -2)
        CFI R25 Frame(CFA_Y, -3)
        CFI R24 Frame(CFA_Y, -4)
        CFI CFA_Y Y+4
        SBIW    R29:R28, 10
        CFI CFA_Y Y+14
        MOV     R24, R16
//   51 	if(KO_conf.en_load == 1)
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+13
        CPI     R16, 1
        BRNE    ??frame_pp_on_off_0
//   52   {
//   53 		// APL  LOC 12 00 "ON"
//   54 		// APL  LOC 12 01 "OFF"
//   55 		unsigned char buffer[2];
//   56 		unsigned char TX_buffer[8];
//   57 	
//   58 		if(command == '0')
        CPI     R24, 48
        BRNE    ??frame_pp_on_off_1
//   59 		{
//   60 			Sensor_mode.power_on_flag =  1;
        LDI     R26, LOW((Sensor_mode + 7))
        LDI     R27, HIGH((Sensor_mode + 7))
        LD      R16, X
        ORI     R16, 0x20
        ST      X, R16
        RJMP    ??frame_pp_on_off_2
//   61 			//KO_conf.status[1] = Status_ON; //reyno 0616
//   62 			//DLL.lightness_load = T_5min5s;					// 5s
//   63 			//DLL.calc_OK_flag = 0; //reyno 0616
//   64 		}
//   65 		else if(command == '1')
??frame_pp_on_off_1:
        CPI     R24, 49
        BRNE    ??frame_pp_on_off_2
//   66 		{
//   67 			Sensor_mode.power_on_flag = 0; //reyno 0616
        LDI     R26, LOW((Sensor_mode + 7))
        LDI     R27, HIGH((Sensor_mode + 7))
        LD      R16, X
        ANDI    R16, 0xDF
        ST      X, R16
//   68 			//KO_conf.status[1] = Status_OFF;
//   69 			Time_delay.detect_waitting = OFF_delay_2s;	// 0527,after send "OFF",the new detect will be enable 2s later
        LDI     R16, 208
        LDI     R17, 7
        STS     (Time_delay + 11), R16
        STS     (Time_delay + 12), R17
//   70 		}
//   71 		
//   72 		if(KO_conf.AddressType == 0)	
??frame_pp_on_off_2:
        LDD     R16, Z+1
        TST     R16
        BRNE    ??frame_pp_on_off_3
//   73 		{
//   74 			CharToStr(KO_conf.DesAdd,buffer);
        MOVW    R19:R18, R29:R28
        LDD     R16, Z+2
        RJMP    ??frame_pp_on_off_4
//   75 			TX_buffer[0] = buffer[0];
//   76 			TX_buffer[1] = buffer[1];
//   77 		}
//   78 		else if(KO_conf.AddressType == 2)							// 0526
??frame_pp_on_off_3:
        LDD     R16, Z+1
        CPI     R16, 2
        BRNE    ??frame_pp_on_off_5
//   79 		{
//   80 			CharToStr(KO_conf.Reference, buffer);						// KO_conf.DesAdd
        MOVW    R19:R18, R29:R28
        LDD     R16, Z+5
??frame_pp_on_off_4:
        CALL    CharToStr
//   81 			TX_buffer[0] = buffer[0];
        LD      R16, Y
        STD     Y+2, R16
//   82 			TX_buffer[1] = buffer[1];
        LDD     R16, Y+1
        STD     Y+3, R16
//   83 			//CharToStr(KO_conf.GR, buffer);						// KO_conf.DesAdd
//   84 			//TX_buffer[2] = buffer[0];
//   85 			//TX_buffer[3] = buffer[1];
//   86 		}
//   87 		TX_buffer[2] = '0';
??frame_pp_on_off_5:
        LDI     R16, 48
        STD     Y+4, R16
//   88 		TX_buffer[3] = '0';		
        STD     Y+5, R16
//   89 		TX_buffer[4] = '1';
        LDI     R16, 49
        STD     Y+6, R16
//   90 		TX_buffer[5] = '2';
        LDI     R16, 50
        STD     Y+7, R16
//   91 		TX_buffer[6] = '0';
        LDI     R16, 48
        STD     Y+8, R16
//   92 		TX_buffer[7] = command;
        STD     Y+9, R24
//   93 		send_frame_pp_broad(TX_buffer, TRANS_DELAY);				// 0707
        LDI     R18, 50
        LDI     R19, 0
        MOVW    R17:R16, R29:R28
        SUBI    R16, 254
        SBCI    R17, 255
        CALL    send_frame_pp_broad
//   94 	}	
//   95 }
??frame_pp_on_off_0:
        ADIW    R29:R28, 10
        CFI CFA_Y Y+4
        LDI     R30, 4
        JMP     ?EPILOGUE_B4_L09
        CFI EndBlock cfiBlock1
//   96 
//   97 //******************************************************************************
//   98 // 	start time delay for load
//   99 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  100 void Start_Time_Delay(void)
Start_Time_Delay:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Start_Time_Delay
//  101 {
        MOVW    R21:R20, R27:R26
//  102 	Time_delay.Walk_Through_Timeout = 0;	
        LDI     R30, LOW(Time_delay)
        LDI     R31, (Time_delay) >> 8
        LDI     R16, 0
        STD     Z+1, R16
        STD     Z+2, R16
//  103 	Time_delay.timer_delay_set.count = Delay_Time_set;	// start time count from Delay_Time_set--
        LDI     R26, LOW(Delay_Time_set)
        LDI     R27, (Delay_Time_set) >> 8
        LD      R16, X+
        LD      R17, X+
        LD      R18, X+
        LD      R19, X
        STD     Z+26, R16
        STD     Z+27, R17
        STD     Z+28, R18
        STD     Z+29, R19
//  104 	Time_delay.timer_delay_set.time_out = 0;
        LDI     R16, 0
        STD     Z+34, R16
//  105 	Time_delay.timer_delay_set.enabled = 1;
        LDI     R16, 1
        STD     Z+35, R16
//  106 	Time_delay.timer_delay_set.started = 1;
        STD     Z+36, R16
//  107 }
        MOVW    R27:R26, R21:R20
        RET
        CFI EndBlock cfiBlock2
//  108 
//  109 //******************************************************************************
//  110 // 	stop time delay for load
//  111 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  112 void Stop_allTimer(void)
Stop_allTimer:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Stop_allTimer
//  113 {
//  114 	Time_delay.Re_Trigger_senconds = 0;
        LDI     R30, LOW(Time_delay)
        LDI     R31, (Time_delay) >> 8
        LDI     R16, 0
        ST      Z, R16
//  115 	Time_delay.Walk_Through_Timeout = 0;
        STD     Z+1, R16
        STD     Z+2, R16
//  116 	Time_delay.timer_takeline.enabled = 0;
        STD     Z+46, R16
//  117 	Time_delay.timer_delay_set.enabled = 0;
        STD     Z+35, R16
//  118 	if(KO_conf.LightReg == 1)			// alan 0729
        LDS     R16, (KO_conf + 28)
        CPI     R16, 1
        BRNE    ??Stop_allTimer_0
//  119 	{
//  120 			DLL.start_regulation = 0;
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R16, Z+54
        ANDI    R16, 0xFE
        STD     Z+54, R16
//  121 			ClrBit(KO_conf.status[0],Status_Regulationing);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ANDI    R16, 0xBF
        STD     Z+45, R16
//  122 	}
//  123 }
??Stop_allTimer_0:
        RET
        CFI EndBlock cfiBlock3
//  124 
//  125 //******************************************************************************
//  126 // 	update the time dalay base on Automatic or walkthrough
//  127 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  128 void Call_detect_delay(void)
Call_detect_delay:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Call_detect_delay
//  129 {
//  130   if(KO_conf.FuncMod == Auto_Walk_thru)		// 在Auto_Walk_thru模式时
        FUNCALL Call_detect_delay, Start_Time_Delay
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDS     R16, (KO_conf + 29)
        CPI     R16, 2
        BRNE    ??Call_detect_delay_0
//  131 	{
//  132 		if(Delay_Time_set > Walkthru_delay)		
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 181
        LDI     R20, 0
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BRCS    ??Call_detect_delay_1
//  133 			Time_delay.Walk_Through_Timeout = Walkthru_delay;
        LDI     R16, 180
        STS     (Time_delay + 1), R16
        STS     (Time_delay + 2), R20
        RJMP    ??Call_detect_delay_2
//  134 		else									
//  135 			Time_delay.Walk_Through_Timeout = Delay_Time_set;
??Call_detect_delay_1:
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        STS     (Time_delay + 1), R16
        STS     (Time_delay + 2), R17
//  136 	  	
//  137 		Walk_Through_flag = 1;
??Call_detect_delay_2:
        LDI     R16, 1
        STS     Walk_Through_flag, R16
//  138 		First_detection_enable = 1;
        STS     First_detection_enable, R16
        RET
//  139 	}
//  140 	else
//  141 	{
//  142 		Start_Time_Delay();	
??Call_detect_delay_0:
        RCALL   Start_Time_Delay
//  143 		Walk_Through_flag = 0;
        LDI     R16, 0
        STS     Walk_Through_flag, R16
//  144 	}
//  145 }
        RET
        CFI EndBlock cfiBlock4
//  146 
//  147 //*****************************************************************************************
//  148 // 	to check the time delay between the detection and the first detection > 20s
//  149 //*****************************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  150 void WT_20s_detect(void)               					// to judge if the time between the detection and the first detection is longer than 20s
WT_20s_detect:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function WT_20s_detect
//  151 {
//  152     if(Walk_Through_flag == 1)									// in walk_through mode
        FUNCALL WT_20s_detect, Start_Time_Delay
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL WT_20s_detect, Start_Time_Delay
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BREQ    $+2+2
        RJMP    ??WT_20s_detect_0
//  153 		{
//  154 				if( ((Time_delay.Walk_Through_Timeout < 160)&&(Delay_Time_set >= Walkthru_delay))
//  155 					 ||((Time_delay.Walk_Through_Timeout < Delay_Time_set-20)&&(Delay_Time_set < Walkthru_delay)))	
        LDS     R16, (Time_delay + 1)
        LDS     R17, (Time_delay + 2)
        CPI     R16, 160
        LDI     R18, 0
        CPC     R17, R18
        BRCC    ??WT_20s_detect_1
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 180
        LDI     R20, 0
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BRCC    ??WT_20s_detect_2
??WT_20s_detect_1:
        LDS     R20, (Time_delay + 1)
        LDS     R21, (Time_delay + 2)
        LDI     R22, 0
        LDI     R23, 0
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        SUBI    R16, 20
        SBCI    R17, 0
        SBCI    R18, 0
        SBCI    R19, 0
        CP      R20, R16
        CPC     R21, R17
        CPC     R22, R18
        CPC     R23, R19
        BRCC    ??WT_20s_detect_3
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 180
        CPC     R17, R22
        CPC     R18, R22
        CPC     R19, R22
        BRCC    ??WT_20s_detect_3
//  156 				{																				//(Walkthru_delay C T_20s))
//  157 					Walk_Through_flag = 0;
??WT_20s_detect_2:
        LDI     R16, 0
        STS     Walk_Through_flag, R16
//  158 					Time_delay.Walk_Through_Timeout = 0;	// detection is occur after 20s since first detection, use the set time delay
        STS     (Time_delay + 1), R16
        STS     (Time_delay + 2), R16
//  159 					Start_Time_Delay();										// when detection is occur after 20s, use the set time delay instead of Walk_Through_Timeout
        RJMP    ??WT_20s_detect_0
//  160 				}
//  161 				else																		// update time delay
//  162 				{
//  163 					if(Delay_Time_set > Walkthru_delay)		
??WT_20s_detect_3:
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 181
        CPC     R17, R22
        CPC     R18, R22
        CPC     R19, R22
        BRCS    ??WT_20s_detect_4
//  164 			  		Time_delay.Walk_Through_Timeout = Walkthru_delay;
        LDI     R16, 180
        STS     (Time_delay + 1), R16
        STS     (Time_delay + 2), R22
        RET
//  165 					else							
//  166 			 	 		Time_delay.Walk_Through_Timeout = Delay_Time_set;
??WT_20s_detect_4:
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        STS     (Time_delay + 1), R16
        STS     (Time_delay + 2), R17
        RET
//  167 				}
//  168 		}
//  169 		else
//  170 		{
//  171 				Start_Time_Delay();											// update the delay time after received the GS presence
??WT_20s_detect_0:
        RCALL   Start_Time_Delay
//  172 		}
//  173 }
        RET
        CFI EndBlock cfiBlock5
//  174 
//  175 //******************************************************************************
//  176 // 	send the frame presence for the GS
//  177 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  178 void GS_presence_send(void)
GS_presence_send:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function GS_presence_send
//  179 {
        FUNCALL GS_presence_send, Mode_frame_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL GS_presence_send, Mode_frame_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDS     R16, (KO_conf + 14)
        CPI     R16, 1
        BRNE    ??GS_presence_send_0
//  180         if(KO_conf.en_GS_main_group ==1)
//  181         {
//  182 	      //Mode_frame_GR(KO_conf.GR,pre);													// send GR frame presence;	B5 GG 1D 00
//  183 	      if(KO_conf.GS1 != 0)	Mode_frame_GR(KO_conf.GS1, Gs1);		// send frame "presence detection" to the GS1;
        LDS     R16, (KO_conf + 7)
        TST     R16
        BREQ    ??GS_presence_send_1
        LDI     R17, 5
        LDS     R16, (KO_conf + 7)
        CALL    Mode_frame_GR
//  184 	      if(KO_conf.GS2 != 0)	Mode_frame_GR(KO_conf.GS2, Gs2);		// send frame "presence detection" to the GS2;
??GS_presence_send_1:
        LDS     R16, (KO_conf + 8)
        TST     R16
        BREQ    ??GS_presence_send_0
        LDI     R17, 6
        LDS     R16, (KO_conf + 8)
        CALL    Mode_frame_GR
//  185         }
//  186 }
??GS_presence_send_0:
        RET
        CFI EndBlock cfiBlock6
//  187 
//  188 //******************************************************************************
//  189 // 					send the frame ON
//  190 //			in Partial_ON mode, 	APL LOC 12 00
//  191 //			in other mode,				B5  GR  12 00
//  192 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  193 void frame_ON_send(void)
frame_ON_send:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function frame_ON_send
//  194 {
        FUNCALL frame_ON_send, frame_pp_on_off
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_ON_send, Mode_frame_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_ON_send, regulation_timer_initial
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDS     R16, (KO_conf + 13)
        CPI     R16, 1
        BRNE    ??frame_ON_send_0
//  195      if(KO_conf.en_load == 1)				//0618
//  196      {
//  197 			 flags.dimmer_ON_sended = 0;
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+12
        LDD     R17, Z+13
        ANDI    R16, 0xF7
        STD     Z+13, R17
        STD     Z+12, R16
//  198        	if( KO_conf.FuncMod == Partial_ON || KO_conf.AddressType ==0)   // Parital ON or P2P
        LDS     R16, (KO_conf + 29)
        CPI     R16, 5
        BREQ    ??frame_ON_send_1
        LDS     R16, (KO_conf + 1)
        TST     R16
        BRNE    ??frame_ON_send_2
//  199 				{
//  200 						//if( KO_conf.Reference != 0 )	Mode_frame_P2P('1','2','0','0','0','0','0');		
//  201 						frame_pp_on_off('0');             		// send frame ON	    0526    	
??frame_ON_send_1:
        LDI     R16, 48
        RCALL   frame_pp_on_off
        RJMP    ??frame_ON_send_3
//  202 				}
//  203 				else																	// GR on
//  204 				{
//  205 						if(KO_conf.GR !=0)		Mode_frame_GR(KO_conf.GR,ON);		
??frame_ON_send_2:
        LDS     R16, (KO_conf + 6)
        TST     R16
        BREQ    ??frame_ON_send_3
        LDI     R17, 1
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  206 				}
//  207 				//KO_conf.status[1] = Status_ON;				//0515
//  208 				if(KO_conf.LightReg == 1)			// alan 0729
??frame_ON_send_3:
        LDS     R16, (KO_conf + 28)
        CPI     R16, 1
        BRNE    ??frame_ON_send_0
//  209 				{
//  210 						DLL.start_regulation = 1;
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R16, Z+54
        ORI     R16, 0x01
        STD     Z+54, R16
//  211 						SetBit(KO_conf.status[0],Status_Regulationing);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ORI     R16, 0x40
        STD     Z+45, R16
//  212 						regulation_timer_initial();
        CALL    regulation_timer_initial
//  213 				}
//  214      }
//  215 }
??frame_ON_send_0:
        RET
        CFI EndBlock cfiBlock7
//  216 
//  217 //******************************************************************************
//  218 // 				send the frame OFF
//  219 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  220 void frame_OFF_send(void)
frame_OFF_send:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function frame_OFF_send
//  221 {
        FUNCALL frame_OFF_send, dimmer_command
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_OFF_send, Mode_frame_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_OFF_send, Mode_frame_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_OFF_send, frame_presence
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL frame_OFF_send, frame_pp_on_off
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDS     R16, (KO_conf + 13)
        CPI     R16, 1
        BRNE    ??frame_OFF_send_0
//  222      if(KO_conf.en_load == 1)			//0618
//  223      {
//  224 			 if( KO_conf.LightReg == 1 && SCS_received.P2P_dimmer_flag == 1 && DLL.start_regulation == 1)
        LDS     R16, (KO_conf + 28)
        CPI     R16, 1
        BRNE    ??frame_OFF_send_1
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRS    R16, 1
        RJMP    ??frame_OFF_send_1
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R16, Z+54
        SBRS    R16, 0
        RJMP    ??frame_OFF_send_1
//  225 			 {
//  226 				 dimmer_command(OFF,0);
        LDI     R17, 0
        LDI     R16, 2
        CALL    dimmer_command
        RJMP    ??frame_OFF_send_2
//  227 			 }
//  228 			 else
//  229 			 {
//  230           if(KO_conf.AddressType == 2 && KO_conf.GR != 0)		//GR
??frame_OFF_send_1:
        LDS     R16, (KO_conf + 1)
        CPI     R16, 2
        BRNE    ??frame_OFF_send_3
        LDS     R16, (KO_conf + 6)
        TST     R16
        BREQ    ??frame_OFF_send_3
//  231 					{
//  232 			 				Mode_frame_GR(KO_conf.GR,nopre);		// send Group "no presence detection"	B5 GG 1D 01
        LDI     R17, 4
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  233           		Mode_frame_GR(KO_conf.GR,OFF);			// send Group "OFF" frame	B5 GG 12 01
        LDI     R17, 2
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
        RJMP    ??frame_OFF_send_2
//  234 					}
//  235 					else if(KO_conf.AddressType == 0)				//P2P
??frame_OFF_send_3:
        LDS     R16, (KO_conf + 1)
        TST     R16
        BRNE    ??frame_OFF_send_2
//  236 					{
//  237 						frame_presence('1'); //0709
        LDI     R16, 49
        RCALL   frame_presence
//  238 						frame_pp_on_off('1');             		// send frame OFF    0618
        LDI     R16, 49
        RCALL   frame_pp_on_off
//  239 					}
//  240 			 }
//  241 			
//  242 			 DLL.start_regulation = 0;							// alan 0729 stop regulation when time delay over
??frame_OFF_send_2:
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R16, Z+54
        ANDI    R16, 0xFE
        STD     Z+54, R16
//  243 			 ClrBit(KO_conf.status[0],Status_Regulationing);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ANDI    R16, 0xBF
        STD     Z+45, R16
//  244      }
//  245 }
??frame_OFF_send_0:
        RET
        CFI EndBlock cfiBlock8
//  246 
//  247 //*******************************************************************************
//  248 // 			used for the Alert when the time dalay equal to 1min or 30s ir 10s
//  249 //*******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  250 void Delay_Alert(void)
Delay_Alert:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function Delay_Alert
//  251 {
//  252 	
//  253   	if((Time_delay.Walk_Through_Timeout==60)||(Time_delay.Walk_Through_Timeout==30)
//  254 	   ||(Time_delay.Walk_Through_Timeout==10)||(Time_delay.timer_delay_set.count==60)
//  255 		 ||(Time_delay.timer_delay_set.count==30)||(Time_delay.timer_delay_set.count==10))
        FUNCALL Delay_Alert, buzzer_ms
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDI     R30, LOW(Time_delay)
        LDI     R31, (Time_delay) >> 8
        LDD     R16, Z+1
        LDD     R17, Z+2
        CPI     R16, 60
        LDI     R18, 0
        CPC     R17, R18
        BREQ    ??Delay_Alert_0
        LDD     R16, Z+1
        LDD     R17, Z+2
        CPI     R16, 30
        CPC     R17, R18
        BREQ    ??Delay_Alert_0
        LDD     R16, Z+1
        LDD     R17, Z+2
        CPI     R16, 10
        CPC     R17, R18
        BREQ    ??Delay_Alert_0
        LDD     R16, Z+26
        LDD     R17, Z+27
        LDD     R18, Z+28
        LDD     R19, Z+29
        CPI     R16, 60
        LDI     R20, 0
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BREQ    ??Delay_Alert_0
        LDD     R16, Z+26
        LDD     R17, Z+27
        LDD     R18, Z+28
        LDD     R19, Z+29
        CPI     R16, 30
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BREQ    ??Delay_Alert_0
        LDD     R16, Z+26
        LDD     R17, Z+27
        LDD     R18, Z+28
        LDD     R19, Z+29
        CPI     R16, 10
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BRNE    ??Delay_Alert_1
//  256 	  {		
//  257 			switch(KO_conf.Alert)
??Delay_Alert_0:
        LDS     R16, (KO_conf + 34)
        SUBI    R16, 2
        BREQ    ??Delay_Alert_2
        DEC     R16
        BRNE    ??Delay_Alert_1
//  258 			{
//  259 				case Disabled:
//  260 					// do nothing
//  261 					break;
//  262 				case Visual:
//  263 	
//  264 					break;
//  265 				case Acustic:
//  266 					buzzer_ms(500);
??Delay_Alert_2:
        LDI     R16, 244
        LDI     R17, 1
        CALL    buzzer_ms
//  267 		
//  268 					break;
//  269 				case Visual_Acustic:
//  270 					buzzer_ms(500);
//  271 					break;	
//  272 			
//  273 				default: break;			
//  274 			}
//  275 	  }	
//  276 
//  277 }
??Delay_Alert_1:
        RET
        CFI EndBlock cfiBlock9
//  278 	
//  279 //*******************************************************************************
//  280 // 	used for takeline when the sensor want to send the frame  presence + ON
//  281 //*******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  282 void ON_takeline(void)
ON_takeline:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function ON_takeline
//  283 {		
        FUNCALL ON_takeline, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL ON_takeline, frame_ON_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL ON_takeline, Call_detect_delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        LDS     R16, (Time_delay + 45)
        CPI     R16, 1
        BRNE    ??ON_takeline_0
//  284 	if(Time_delay.timer_takeline.time_out == 1)					// when time is out, send the frames
//  285 	{													
//  286 		Mode_frame_GR(KO_conf.GR,pre);										// send Group "presence detection"	B5 GG 1D 00
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  287 		frame_ON_send();
        RCALL   frame_ON_send
//  288 
//  289 		Time_delay.timer_takeline.time_out = 0;
        LDI     R16, 0
        STS     (Time_delay + 45), R16
//  290 		Time_delay.timer_takeline.started = 0;
        STS     (Time_delay + 47), R16
//  291 		Sensor_mode.ON_takeline_waitsend = 0;							// to indicate this frame had been sent
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        ADIW    R27:R26, 7
        LD      R16, X
        ANDI    R16, 0xFE
        ST      X, R16
        SBIW    R27:R26, 7
//  292 		Sensor_mode.flag_leader_group = 1;
        ADIW    R27:R26, 5
        LD      R16, X
        ORI     R16, 0x02
        ST      X, R16
        SBIW    R27:R26, 5
//  293 		Sensor_mode.mode_state = Maintain_state;
        LDI     R16, 2
        STS     Sensor_mode, R16
//  294 
//  295 		Call_detect_delay();
        RCALL   Call_detect_delay
//  296 		Sensor_mode.maintain_pre = 1;											//0518
        ADIW    R27:R26, 7
        LD      R16, X
        ORI     R16, 0x10
        ST      X, R16
        SBIW    R27:R26, 7
//  297 		Sensor_mode.presence_20sinterval = presence_20s;		//0518
        LDI     R16, 32
        LDI     R17, 78
        ADIW    R27:R26, 3
        ST      X+, R16
        ST      X, R17
//  298 	}
//  299 }
??ON_takeline_0:
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock10
//  300 
//  301 //******************************************************************************
//  302 // 	used for takeline when the sensor want to send the frame  no presence + OFF
//  303 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  304 void OFF_takeline(void)
OFF_takeline:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function OFF_takeline
//  305 {					
//  306 	if(Time_delay.timer_takeline.time_out == 1)
        FUNCALL OFF_takeline, frame_OFF_send
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDS     R16, (Time_delay + 45)
        CPI     R16, 1
        BRNE    ??OFF_takeline_0
//  307 	{		
//  308 		frame_OFF_send();
        RCALL   frame_OFF_send
//  309 		Sensor_mode.no_prence_off_send = 1;								// to  indicate this frame had been sent
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+5
        ORI     R16, 0x20
        STD     Z+5, R16
//  310 		Sensor_mode.OFF_takeline_waitsend = 0;
        LDD     R16, Z+7
        ANDI    R16, 0xFD
        STD     Z+7, R16
//  311 		Sensor_mode.flag_leader_group = 1;
        LDD     R16, Z+5
        ORI     R16, 0x02
        STD     Z+5, R16
//  312 		Time_delay.timer_takeline.started = 0;
        LDI     R16, 0
        STS     (Time_delay + 47), R16
//  313 	}
//  314 }
??OFF_takeline_0:
        RET
        CFI EndBlock cfiBlock11
//  315 
//  316 //******************************************************************************
//  317 // 	Check the frame received on SCS	when manual is enabled
//  318 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  319 void function_check_status(void)
function_check_status:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function function_check_status
//  320 {	
        FUNCALL function_check_status, Stop_allTimer
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_check_status, Call_detect_delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_check_status, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_check_status, Start_Time_Delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_check_status, Start_Time_Delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_check_status, Check_SCS_received
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
//  321 
//  322 //******************************************************************************
//  323 // 	if received update ON/OFF/LEVEL
//  324 //******************************************************************************
//  325   if((SCS_received.update_state_ON == 1)||(SCS_received.update_state_OFF == 1)||(SCS_received.update_state_LEVEL == 1))
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRC    R16, 7
        RJMP    ??function_check_status_0
        LDS     R16, (SCS_received + 1)
        ANDI    R16, 0x03
        BREQ    ??function_check_status_1
//  326 	{
//  327       if(SCS_received.update_state_ON == 1)				// 0519
??function_check_status_0:
        LD      R16, Z
        SBRS    R16, 7
        RJMP    ??function_check_status_2
//  328 			{
//  329 				SCS_received.update_state_ON = 0;
        LD      R16, Z
        ANDI    R16, 0x7F
        ST      Z, R16
//  330 				SCS_received.update_on_wait = 0;
        LDS     R16, (SCS_received + 1)
        ANDI    R16, 0xF3
        STS     (SCS_received + 1), R16
//  331 			}
//  332 	  		if(SCS_received.update_state_OFF == 1)  	// 0519
??function_check_status_2:
        LDD     R16, Z+1
        SBRS    R16, 0
        RJMP    ??function_check_status_3
//  333 			{
//  334 				SCS_received.update_state_OFF = 0;
//  335 				SCS_received.update_off_wait = 0;
        LDS     R16, (SCS_received + 1)
        ANDI    R16, 0xCE
        STS     (SCS_received + 1), R16
//  336 			}
//  337 		  	
//  338 			SCS_received.update_state_LEVEL = 0;
??function_check_status_3:
        LDD     R16, Z+1
        ANDI    R16, 0xFD
        STD     Z+1, R16
//  339 			
//  340 			if(Sensor_mode.mode_state == Initial_state)		//0520
        LDS     R16, Sensor_mode
        CPI     R16, 1
        BRNE    ??function_check_status_4
//  341 			{
//  342 				Stop_allTimer();
        RCALL   Stop_allTimer
//  343 			}
//  344 			if(Sensor_mode.mode_state == Re_Trigger_State)
??function_check_status_4:
        LDS     R16, Sensor_mode
        CPI     R16, 3
        BRNE    ??function_check_status_1
//  345 			{
//  346 				if ( (Time_delay.Re_Trigger_senconds <=4 && KO_conf.FuncMod != ManualON_Auto_OFF)
//  347 				   ||(Time_delay.Re_Trigger_senconds <= Re_Trigger_30s - 1 && KO_conf.FuncMod == ManualON_Auto_OFF))
        LDS     R16, Time_delay
        CPI     R16, 5
        BRCC    ??function_check_status_5
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BRNE    ??function_check_status_6
??function_check_status_5:
        LDS     R16, Time_delay
        CPI     R16, 30
        BRCC    ??function_check_status_1
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BRNE    ??function_check_status_1
//  348 				{
//  349 			  		Sensor_mode.mode_state = Maintain_state;
??function_check_status_6:
        LDI     R16, 2
        STS     Sensor_mode, R16
//  350 						Call_detect_delay();
        RCALL   Call_detect_delay
??function_check_status_1:
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BREQ    $+2+2
        RJMP    ??function_check_status_7
//  351 				}
//  352 			}
//  353 	}
//  354 	
//  355 	if(KO_conf.FuncMod == ManualON_Auto_OFF)//((KO_conf.FuncMod == ManualON_Manual_OFF)||(KO_conf.FuncMod == ManualON_Auto_OFF))// 在manual mode，sensor不接收任何来自SCS总线上的帧
//  356 	{
//  357 		if(SCS_received.GS_presence == 1)
        LDI     R26, LOW(SCS_received)
        LDI     R27, (SCS_received) >> 8
        LD      R16, X
        SBRS    R16, 2
        RJMP    ??function_check_status_8
//  358 		{
//  359 				SCS_received.GS_presence = 0;
        LD      R16, X
        ANDI    R16, 0xFB
        ST      X, R16
//  360 				Time_delay.GS_200ms.stack_top = 200;
        LDI     R16, 200
        LDI     R17, 0
        LDI     R26, ((Time_delay + 25) & 0xff) & 0xFF
        LDI     R27, (((Time_delay + 281) >> 8) & 0xff) & 0xFF
        ADIW    R27:R26, 4
        ST      X+, R16
        ST      X+, R17
        ST      X+, R17
        ST      X, R17
//  361 				Time_delay.GS_200ms.count = 0;
        LDI     R30, ((Time_delay + 25) & 0xff) & 0xFF
        LDI     R31, (((Time_delay + 281) >> 8) & 0xff) & 0xFF
        ST      Z, R17
        STD     Z+1, R17
        STD     Z+2, R17
        STD     Z+3, R17
//  362 				Time_delay.GS_200ms.time_out = 0;
        STS     (Time_delay + 289), R17
//  363 				Time_delay.GS_200ms.started = 1;
        LDI     R16, 1
        STS     (Time_delay + 291), R16
//  364 				Time_delay.GS_200ms.enabled = 1;
        STS     (Time_delay + 290), R16
//  365 		}
//  366 		
//  367 		if(Time_delay.GS_200ms.time_out)
??function_check_status_8:
        LDS     R16, (Time_delay + 289)
        TST     R16
        BREQ    ??function_check_status_9
//  368 		{
//  369 			Time_delay.GS_200ms.time_out = 0;
        LDI     R16, 0
        STS     (Time_delay + 289), R16
//  370 		  Mode_frame_GR(KO_conf.GR,pre);	
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  371 			Start_Time_Delay();	
        RCALL   Start_Time_Delay
//  372 		}
//  373 		//Sensor_mode.mode_state = Maintain_state; //0520
//  374 		if(SCS_received.presence == 1)		//in manual, upadate timedelay more 20s,配合其他的auto mode的sensor
??function_check_status_9:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 0
        RJMP    ??function_check_status_10
//  375 		{
//  376 				SCS_received.presence = 0;
        LD      R16, Z
        ANDI    R16, 0xFE
        ST      Z, R16
//  377 				Start_Time_Delay();
        RCALL   Start_Time_Delay
//  378 				//Time_delay.timer_delay_set.count +=  presence_20s;
//  379 		}
//  380 		if(SCS_received.GR_ON == 1)
??function_check_status_10:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 3
        RJMP    ??function_check_status_11
//  381 		{
//  382 				SCS_received.GR_ON = 0;
        LD      R16, Z
        ANDI    R16, 0xF7
        ST      Z, R16
//  383 				Sensor_mode.presen_timeout = 0;			// 0603
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+5
        ANDI    R16, 0xF7
        STD     Z+5, R16
//  384 				// STOP TIME DALAY 0601
//  385 				Time_delay.timer_delay_set.enabled = 0;				// stop time set delay
        LDI     R16, 0
        STS     (Time_delay + 35), R16
//  386 				Time_delay.timer_delay_set.time_out = 0;
        STS     (Time_delay + 34), R16
//  387 				if((KO_conf.FuncMod == ManualON_Auto_OFF)&&(Sensor_mode.flag_leader_group ==1))
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BRNE    ??function_check_status_11
        LDD     R16, Z+5
        SBRS    R16, 1
        RJMP    ??function_check_status_11
//  388 				{
//  389 					Sensor_mode.mode_state = Maintain_state;			// 0601
        LDI     R16, 2
        STS     Sensor_mode, R16
//  390 					Walk_Through_flag = 0;			//reyno 0608
        LDI     R16, 0
        STS     Walk_Through_flag, R16
        RJMP    ??function_check_status_11
//  391 				}
//  392 		}
//  393 	}
//  394 	else
//  395 	{	
//  396 		 	Check_SCS_received();
??function_check_status_7:
        RCALL   Check_SCS_received
//  397 	}
//  398 }
??function_check_status_11:
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock12
//  399 
//  400 
//  401 //******************************************************************************
//  402 // 	Check the frame received on SCS	without manual mode
//  403 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  404 void Check_SCS_received(void)					
Check_SCS_received:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function Check_SCS_received
//  405 {
        FUNCALL Check_SCS_received, Mode_frame_GR
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, frame_ON_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Call_detect_delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, WT_20s_detect
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, frame_ON_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, regulation_timer_initial
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Call_detect_delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Call_detect_delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Mode_frame_GR
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, frame_ON_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, WT_20s_detect
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Mode_frame_GR
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, frame_ON_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, Stop_allTimer
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, frame_M2_answer
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, DLL_setpoint
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, DLL_setpoint
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Check_SCS_received, DLL_setpoint
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        CALL    ?PROLOGUE4_L09
        CFI R27 Frame(CFA_Y, -1)
        CFI R26 Frame(CFA_Y, -2)
        CFI R25 Frame(CFA_Y, -3)
        CFI R24 Frame(CFA_Y, -4)
        CFI CFA_Y Y+4
//  406 		
//  407 //******************************************************************************
//  408 // 	if received GS "ON"
//  409 //******************************************************************************	
//  410 	if(SCS_received.GS_presence == 1)				// the frame sent by extern sensor of GS
        LDI     R24, LOW(Time_delay)
        LDI     R25, (Time_delay) >> 8
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 2
        RJMP    ??Check_SCS_received_0
//  411 	{
//  412 		SCS_received.GS_presence = 0;
        LD      R16, Z
        ANDI    R16, 0xFB
        ST      Z, R16
//  413 		Time_delay.GS_200ms.stack_top = 200;
        LDI     R16, 200
        LDI     R17, 0
        LDI     R30, ((Time_delay + 25) & 0xff) & 0xFF
        LDI     R31, (((Time_delay + 281) >> 8) & 0xff) & 0xFF
        STD     Z+4, R16
        STD     Z+5, R17
        STD     Z+6, R17
        STD     Z+7, R17
//  414 		Time_delay.GS_200ms.count = 0;
        ST      Z, R17
        STD     Z+1, R17
        STD     Z+2, R17
        STD     Z+3, R17
//  415 		Time_delay.GS_200ms.time_out = 0;
        STS     (Time_delay + 289), R17
//  416 		Time_delay.GS_200ms.started = 1;
        LDI     R16, 1
        STS     (Time_delay + 291), R16
//  417 		Time_delay.GS_200ms.enabled = 1;
        STS     (Time_delay + 290), R16
//  418 	}
//  419 	
//  420 	if(Time_delay.GS_200ms.time_out)
??Check_SCS_received_0:
        LDS     R16, (Time_delay + 289)
        TST     R16
        BRNE    $+2+2
        RJMP    ??Check_SCS_received_1
//  421 	{
//  422 		Time_delay.GS_200ms.time_out = 0;
        LDI     R16, 0
        STS     (Time_delay + 289), R16
//  423 		if(Sensor_mode.presence_20sinterval == 0)		//0716
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+3
        LDD     R17, Z+4
        OR      R16, R17
        BRNE    ??Check_SCS_received_2
//  424 		{
//  425 			Mode_frame_GR(KO_conf.GR,pre);			// send GR frame presence;	// B5 GG 1D 00	for this frame, presence maybe doesn't needed
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  426 			Sensor_mode.presence_20sinterval = presence_20s;			// add 0605
        LDI     R16, 32
        LDI     R17, 78
        MOVW    R31:R30, R27:R26
        STD     Z+3, R16
        STD     Z+4, R17
//  427 			Time_delay.GS_wait_22s = 22;			// TO Ingore the 20s presence sent by GS when end detection
        LDI     R16, 22
        STS     (Time_delay + 10), R16
//  428 		}
//  429 		switch(Sensor_mode.mode_state)
??Check_SCS_received_2:
        LDS     R16, Sensor_mode
        SUBI    R16, 1
        BREQ    ??Check_SCS_received_3
        DEC     R16
        BREQ    ??Check_SCS_received_4
        DEC     R16
        BREQ    ??Check_SCS_received_5
        DEC     R16
        BREQ    ??Check_SCS_received_4
        RJMP    ??Check_SCS_received_1
//  430 		{
//  431 			case Initial_state:		
//  432 				if(DLL.current_level < set_point)			
??Check_SCS_received_3:
        LDS     R16, (DLL + 16)
        LDS     R17, (DLL + 17)
        LDS     R18, set_point
        LDS     R19, (set_point + 1)
        CP      R16, R18
        CPC     R17, R19
        BRCC    ??Check_SCS_received_6
//  433 				{
//  434 					//reyno 0622
//  435 					if(KO_conf.LightReg == 1)
        LDS     R18, (KO_conf + 28)
        CPI     R18, 1
        BRNE    ??Check_SCS_received_7
//  436 					{
//  437 						DLL.start_regulation = 1;
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R18, Z+54
        ORI     R18, 0x01
        STD     Z+54, R18
//  438 						SetBit(KO_conf.status[0],Status_Regulationing);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ORI     R16, 0x40
        STD     Z+45, R16
//  439 					}
//  440 					Sensor_mode.flag_leader_group = 1;
??Check_SCS_received_7:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ORI     R16, 0x02
        STD     Z+5, R16
//  441 					Sensor_mode.mode_state = Maintain_state;					
        LDI     R16, 2
        STS     Sensor_mode, R16
//  442 					frame_ON_send();	
        RCALL   frame_ON_send
//  443 					Call_detect_delay();
        RCALL   Call_detect_delay
        RJMP    ??Check_SCS_received_1
//  444 				}
//  445 				else
//  446 				{
//  447 					Start_Time_Delay();					//if still in the initial state
//  448 				}	
//  449 				break;
//  450 			
//  451 			case Maintain_state:
//  452       case Standby_state:
//  453 			        WT_20s_detect();			
??Check_SCS_received_4:
        RCALL   WT_20s_detect
        RJMP    ??Check_SCS_received_1
//  454 				break;
//  455 			
//  456 			case Re_Trigger_State:	
//  457 				Sensor_mode.mode_state = Maintain_state;
??Check_SCS_received_5:
        LDI     R16, 2
        STS     Sensor_mode, R16
//  458 				Time_delay.Re_Trigger_senconds = 0;            // clear the retrigger time delay when leave the retrogger state		
        LDI     R16, 0
        STS     Time_delay, R16
//  459                         frame_ON_send();	
        RCALL   frame_ON_send
//  460 				Start_Time_Delay();														// in the walk_through won't go into the rerigger	
??Check_SCS_received_6:
        RCALL   Start_Time_Delay
//  461 				break;
//  462 				
//  463 			default:  break;				
//  464 		}
//  465 	}
//  466 //******************************************************************************
//  467 // 	if received GR "ON"
//  468 //******************************************************************************
//  469 	if(SCS_received.GR_ON == 1)
??Check_SCS_received_1:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 3
        RJMP    ??Check_SCS_received_8
//  470 	{
//  471 		//reyno 0622
//  472 		if(KO_conf.LightReg == 1)
        LDS     R18, (KO_conf + 28)
        CPI     R18, 1
        BRNE    ??Check_SCS_received_9
//  473 		{	
//  474 			DLL.start_regulation = 1;
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R18, Z+54
        ORI     R18, 0x01
        STD     Z+54, R18
//  475 			SetBit(KO_conf.status[0],Status_Regulationing);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ORI     R16, 0x40
        STD     Z+45, R16
//  476 			regulation_timer_initial();
        CALL    regulation_timer_initial
//  477 		}		
//  478 	       // SCS_received.presence_2_ON = 1;		// debug
//  479 		SCS_received.GR_ON = 0;
??Check_SCS_received_9:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        ANDI    R16, 0xF7
        ST      Z, R16
//  480 	        //Time_delay.frame_200ms.time_out = 0;  // 避免在误执行单独接收presence的程序
//  481 		Time_delay.timer_takeline.enabled = 0;
        LDI     R16, 0
        STS     (Time_delay + 46), R16
//  482 		Time_delay.timer_takeline.started = 0;
        STS     (Time_delay + 47), R16
//  483 		Time_delay.frame_200ms.enabled = 0;
        STS     (Time_delay + 57), R16
//  484 		Time_delay.frame_200ms.started = 0;
        STS     (Time_delay + 58), R16
//  485 		//Sensor_mode.flag_leader_group = 0;					// debug 20090423
//  486 		
//  487 		switch(Sensor_mode.mode_state)
        LDS     R16, Sensor_mode
        SUBI    R16, 1
        BREQ    ??Check_SCS_received_10
        DEC     R16
        BREQ    ??Check_SCS_received_11
        DEC     R16
        BREQ    ??Check_SCS_received_12
        DEC     R16
        BREQ    ??Check_SCS_received_13
        RJMP    ??Check_SCS_received_8
//  488 		{
//  489 			/*case Initial_state:	
//  490 				if(SCS_received.presence_2_ON == 1)		
//  491 				{
//  492 					SCS_received.presence_2_ON = 0;
//  493 					Sensor_mode.mode_state = Standby_state;
//  494 					Sensor_mode.flag_leader_group = 0;	
//  495 					Call_detect_delay();
//  496 				}
//  497 			    break;
//  498        */
//  499 			
//  500 			case Maintain_state:
//  501            if(SCS_received.presence_2_ON != 1)
??Check_SCS_received_11:
        LDD     R16, Z+1
        SBRC    R16, 6
        RJMP    ??Check_SCS_received_10
//  502 							Walk_Through_flag = 0;    								//  received signal ON frame
        LDI     R16, 0
        STS     Walk_Through_flag, R16
//  503       //break;
//  504 			
//  505       case Initial_state:
//  506 				if(SCS_received.presence_2_ON == 1)							//received presence and ON frame
??Check_SCS_received_10:
        LDD     R16, Z+1
        SBRS    R16, 6
        RJMP    ??Check_SCS_received_14
//  507 				{
//  508 					SCS_received.presence_2_ON = 0;	
        LDD     R16, Z+1
        ANDI    R16, 0xBF
        STD     Z+1, R16
//  509          	Sensor_mode.flag_leader_group = 0;
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+5
        ANDI    R16, 0xFD
        STD     Z+5, R16
//  510 					Sensor_mode.mode_state = Standby_state;
        LDI     R16, 4
        STS     Sensor_mode, R16
//  511 					Sensor_mode.presence_send = 1; //Reyno 0623
        LDD     R16, Z+5
        ORI     R16, 0x04
        STD     Z+5, R16
//  512 					Sensor_mode.presence_20sinterval = presence_20s;				// 0717
        LDI     R16, 32
        LDI     R17, 78
        STD     Z+3, R16
        STD     Z+4, R17
//  513 					Call_detect_delay();
        RCALL   Call_detect_delay
        RJMP    ??Check_SCS_received_8
//  514 				}
//  515 				//else if((KO_conf.FuncMod == ManualON_Auto_OFF)&&(Sensor_mode.flag_leader_group ==1))
//  516 				//{
//  517 				//	Sensor_mode.mode_state = Maintain_state;			// 注释，放到前面去处理 0601
//  518 					//Call_detect_delay();
//  519 				//}
//  520 				else
//  521 				{
//  522 					// STOP TIME DALAY 0601
//  523 						Time_delay.timer_delay_set.enabled = 0;				// stop time set delay
??Check_SCS_received_14:
        LDI     R16, 0
        STS     (Time_delay + 35), R16
//  524 						Time_delay.timer_delay_set.time_out = 0;
        STS     (Time_delay + 34), R16
        RJMP    ??Check_SCS_received_8
//  525 				}
//  526 			    break;
//  527 			
//  528 			case Re_Trigger_State:	
//  529 
//  530 				Sensor_mode.mode_state = Maintain_state;				//Standby_state;
??Check_SCS_received_12:
        LDI     R16, 2
        STS     Sensor_mode, R16
//  531 				Time_delay.Re_Trigger_senconds = 0;		
        LDI     R16, 0
        STS     Time_delay, R16
//  532 				Start_Time_Delay();
        RJMP    ??Check_SCS_received_15
//  533 			    break;
//  534 			
//  535 			case Standby_state:
//  536 			
//  537 				if(SCS_received.presence_2_ON == 1)							//received presence and ON frame
??Check_SCS_received_13:
        LDD     R16, Z+1
        SBRS    R16, 6
        RJMP    ??Check_SCS_received_8
//  538 				{
//  539 					SCS_received.presence_2_ON = 0;
        LDD     R16, Z+1
        ANDI    R16, 0xBF
        STD     Z+1, R16
//  540 					Time_delay.Re_Trigger_senconds = 0;
        LDI     R16, 0
        STS     Time_delay, R16
//  541 					Time_delay.Walk_Through_Timeout = 0;
        LDI     R17, 0
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R16
//  542 
//  543 					if(Walk_Through_flag == 1)	
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BRNE    ??Check_SCS_received_15
//  544 						Time_delay.Walk_Through_Timeout = Walkthru_delay;	
        LDI     R16, 180
        STD     Z+1, R16
        STD     Z+2, R17
        RJMP    ??Check_SCS_received_8
//  545 					else
//  546 						Start_Time_Delay();
??Check_SCS_received_15:
        RCALL   Start_Time_Delay
//  547 				}
//  548 				// start light regulation if received signal ON frame
//  549 			    break;
//  550 				
//  551 			default:  break;				
//  552 		}	
//  553 	}
//  554 	
//  555 	
//  556 //******************************************************************************
//  557 // 	if received GR "presence" frame
//  558 //******************************************************************************
//  559 	if(SCS_received.presence == 1)					
??Check_SCS_received_8:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 0
        RJMP    ??Check_SCS_received_16
//  560 	{
//  561 		SCS_received.presence = 0;
        LD      R16, Z
        ANDI    R16, 0xFE
        ST      Z, R16
//  562 		if(Time_delay.frame_200ms.started == 0) // delay 200ms start
        LDS     R16, (Time_delay + 58)
        TST     R16
        BRNE    ??Check_SCS_received_16
//  563 		{
//  564 			Time_delay.frame_200ms.count = 0;
        LDI     R16, 0
        MOVW    R31:R30, R25:R24
        STD     Z+48, R16
        STD     Z+49, R16
        STD     Z+50, R16
        STD     Z+51, R16
//  565 			Time_delay.frame_200ms.time_out = 0;
        STS     (Time_delay + 56), R16
//  566 			Time_delay.frame_200ms.enabled = 1;
        LDI     R16, 1
        STS     (Time_delay + 57), R16
//  567 			Time_delay.frame_200ms.started = 1;
        STS     (Time_delay + 58), R16
//  568 			SCS_received.presence_2_ON = 1;		 // 在200ms内，标志位置一，收到ON帧时可以据此判断接收到的是ON,还是presence+ON
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+1
        ORI     R16, 0x40
        STD     Z+1, R16
//  569 		}
//  570 	}
//  571 	if((Time_delay.frame_200ms.time_out == 1)&&(SCS_received.GR_ON == 0))	// 接收到presence200ms后，还没有接收到ON，就认为是单独的一个presence帧
??Check_SCS_received_16:
        LDS     R16, (Time_delay + 56)
        CPI     R16, 1
        BREQ    $+2+2
        RJMP    ??Check_SCS_received_17
        LD      R16, Z
        SBRC    R16, 3
        RJMP    ??Check_SCS_received_17
//  572 	{
//  573 		// 做在200ms结束后第一次执行到此，并且恰在此时接收到SCS_received.GR_ON==1；就会出现多执行一次presence的bug（很少发生）
//  574 		Time_delay.frame_200ms.time_out = 0;
        LDI     R16, 0
        STS     (Time_delay + 56), R16
//  575 		switch(Sensor_mode.mode_state)
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        LDS     R16, Sensor_mode
        SUBI    R16, 1
        BREQ    ??Check_SCS_received_18
        DEC     R16
        BREQ    ??Check_SCS_received_19
        DEC     R16
        BRNE    $+2+2
        RJMP    ??Check_SCS_received_20
        DEC     R16
        BREQ    ??Check_SCS_received_19
        RJMP    ??Check_SCS_received_17
//  576 		{
//  577 			case Initial_state:	
//  578 				if(DLL.current_level < set_point)
??Check_SCS_received_18:
        LDS     R16, (DLL + 16)
        LDS     R17, (DLL + 17)
        LDS     R18, set_point
        LDS     R19, (set_point + 1)
        CP      R16, R18
        CPC     R17, R19
        BRCC    ??Check_SCS_received_21
//  579 				{
//  580           if(KO_conf.LightReg == 1)
        LDS     R18, (KO_conf + 28)
        CPI     R18, 1
        BRNE    ??Check_SCS_received_22
//  581 					{
//  582 						DLL.start_regulation = 1;  //reyno 0622
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R18, Z+54
        ORI     R18, 0x01
        STD     Z+54, R18
//  583 						SetBit(KO_conf.status[0],Status_Regulationing);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ORI     R16, 0x40
        STD     Z+45, R16
//  584 					}
//  585 						Call_detect_delay();				
??Check_SCS_received_22:
        RCALL   Call_detect_delay
//  586 						if(Sensor_mode.flag_leader_group == 1)
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        SBRS    R16, 1
        RJMP    ??Check_SCS_received_23
//  587 						{
//  588 								Sensor_mode.mode_state = Maintain_state;		
        LDI     R16, 2
        STS     Sensor_mode, R16
//  589 								if(Walk_Through_flag != 1)
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BREQ    ??Check_SCS_received_24
//  590 								{
//  591 									Sensor_mode.maintain_pre = 1;											//0518
        LDD     R16, Z+7
        ORI     R16, 0x10
        STD     Z+7, R16
//  592 									Sensor_mode.presence_20sinterval = presence_20s;		//0518
        LDI     R16, 32
        LDI     R17, 78
        STD     Z+3, R16
        STD     Z+4, R17
//  593 								}
//  594 								Mode_frame_GR(KO_conf.GR,pre);											// send GR frame presence;	// B5 GG 1D 00
        RJMP    ??Check_SCS_received_24
//  595 								frame_ON_send();
//  596 						}
//  597 						else
//  598 						{
//  599 								Sensor_mode.mode_state = Initial_state;
??Check_SCS_received_23:
        LDI     R16, 1
        STS     Sensor_mode, R16
//  600 								Sensor_mode.ON_takeline_waitsend = 1;								//	ON_takeline();	//WITH Special TAKING LINE to send presence+ON							
        LDD     R16, Z+7
        ORI     R16, 0x01
        STD     Z+7, R16
        RJMP    ??Check_SCS_received_17
//  601 						}						
//  602 				}
//  603 				else
//  604 				{
//  605 						Start_Time_Delay();																			// start time dalay if still in initial state
??Check_SCS_received_21:
        RCALL   Start_Time_Delay
        RJMP    ??Check_SCS_received_17
//  606 				}
//  607 				break;
//  608 			
//  609 			case Maintain_state:
//  610 	        case Standby_state:
//  611 				WT_20s_detect();
??Check_SCS_received_19:
        RCALL   WT_20s_detect
//  612         Sensor_mode.presence_20sinterval = presence_20s;
        LDI     R16, 32
        LDI     R17, 78
        MOVW    R31:R30, R27:R26
        STD     Z+3, R16
        STD     Z+4, R17
//  613 				Sensor_mode.maintain_pre = 1;
        LDD     R16, Z+7
        ORI     R16, 0x10
        STD     Z+7, R16
//  614 				Sensor_mode.presence_send = 1; //Reyno 0623
        LDD     R16, Z+5
        ORI     R16, 0x04
        STD     Z+5, R16
        RJMP    ??Check_SCS_received_17
//  615 				//Mode_frame_GR(KO_conf.GR,pre);			// I don't think the sensor should resend the presence frame after it received a presence frame
//  616 				// Mode_frame_GR('5','1','D','0','B');		// B5 GG 1D 00  for debug
//  617 				break;
//  618 				
//  619 			case Re_Trigger_State:	
//  620 			
//  621 				Sensor_mode.mode_state = Maintain_state;
??Check_SCS_received_20:
        LDI     R16, 2
        STS     Sensor_mode, R16
//  622 				Time_delay.Re_Trigger_senconds = 0; 		
        LDI     R16, 0
        STS     Time_delay, R16
//  623 				Start_Time_Delay();
        RCALL   Start_Time_Delay
//  624 				Mode_frame_GR(KO_conf.GR,pre);				// send GR frame presence;
??Check_SCS_received_24:
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  625 				frame_ON_send();
        RCALL   frame_ON_send
//  626 				break;
//  627 			
//  628 			default: break;				
//  629 		}		
//  630 		
//  631 	}
//  632 	
//  633 //******************************************************************************
//  634 // 	if received GR "NO presence" or "OFF"
//  635 //******************************************************************************
//  636 	if(SCS_received.no_presence == 1)
??Check_SCS_received_17:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 1
        RJMP    ??Check_SCS_received_25
//  637 	{
//  638 		SCS_received.no_presence = 0;
        LD      R16, Z
        ANDI    R16, 0xFD
        ST      Z, R16
//  639 		SCS_received.nopresence_2_OFF = 1;				//  received no presence frame
        LDD     R16, Z+1
        ORI     R16, 0x80
        STD     Z+1, R16
//  640 	}
//  641 	
//  642 	if(KO_conf.AddressType == PP)
??Check_SCS_received_25:
        LDS     R18, (KO_conf + 1)
        TST     R18
        BRNE    ??Check_SCS_received_26
//  643 	{
//  644 		switch(Sensor_mode.mode_state)
        LDS     R16, Sensor_mode
        CPI     R16, 2
        BRNE    ??Check_SCS_received_26
//  645 		{
//  646 			case Initial_state:	
//  647 			break;
//  648 				
//  649 			case Maintain_state:
//  650 				if(SCS_received.nopresence_2_OFF == 1)
        LDD     R16, Z+1
        SBRS    R16, 7
        RJMP    ??Check_SCS_received_26
//  651 				{
//  652 				  SCS_received.nopresence_2_OFF = 0;			
        LDD     R16, Z+1
        ANDI    R16, 0x7F
        STD     Z+1, R16
//  653 					Sensor_mode.flag_leader_group = 0;	
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+5
        ANDI    R16, 0xFD
        STD     Z+5, R16
//  654 					Time_delay.timer_takeline.enabled = 0;		// after received the frame no presence and OFF, stop the taking line
        LDI     R16, 0
        STS     (Time_delay + 46), R16
//  655 					Time_delay.timer_takeline.time_out = 0;			
        STS     (Time_delay + 45), R16
//  656 					Sensor_mode.mode_state = Standby_state;
        LDI     R16, 4
        STS     Sensor_mode, R16
//  657 
//  658 					if(KO_conf.FuncMod != ManualON_Auto_OFF)	
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BREQ    ??Check_SCS_received_27
//  659 					  Time_delay.Re_Trigger_senconds = Re_Trigger_5s;
        LDI     R16, 5
        RJMP    ??Check_SCS_received_28
//  660 					else						
//  661 					  Time_delay.Re_Trigger_senconds = Re_Trigger_30s;
??Check_SCS_received_27:
        LDI     R16, 30
??Check_SCS_received_28:
        STS     Time_delay, R16
//  662 				}
//  663 			break;
//  664 			
//  665 			case Re_Trigger_State:
//  666 			break;
//  667 			
//  668 			case Standby_state:
//  669 			break;
//  670 			
//  671 			default:break;
//  672 		}
//  673 	}
//  674 	
//  675 	if(SCS_received.GR_OFF == 1)
??Check_SCS_received_26:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LD      R16, Z
        SBRS    R16, 4
        RJMP    ??Check_SCS_received_29
//  676 	{
//  677 		SCS_received.GR_OFF = 0;
        LD      R16, Z
        ANDI    R16, 0xEF
        ST      Z, R16
//  678 
//  679 		switch(Sensor_mode.mode_state)
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        LDS     R16, Sensor_mode
        SUBI    R16, 1
        BREQ    ??Check_SCS_received_30
        DEC     R16
        BREQ    ??Check_SCS_received_31
        DEC     R16
        BRNE    $+2+2
        RJMP    ??Check_SCS_received_32
        DEC     R16
        BRNE    $+2+2
        RJMP    ??Check_SCS_received_33
        RJMP    ??Check_SCS_received_29
//  680 		{
//  681 			case Initial_state:	
//  682 				if(SCS_received.nopresence_2_OFF == 1)			//received no presence and OFF frame
??Check_SCS_received_30:
        LDD     R16, Z+1
        SBRS    R16, 7
        RJMP    ??Check_SCS_received_29
//  683 				{
//  684 					SCS_received.nopresence_2_OFF = 0;
        LDD     R16, Z+1
        ANDI    R16, 0x7F
        STD     Z+1, R16
//  685 					Sensor_mode.flag_leader_group = 0;	
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xFD
        STD     Z+5, R16
//  686 					Time_delay.timer_takeline.enabled = 0;		// after received the frame no presence and OFF, stop the taking line
        LDI     R16, 0
        STS     (Time_delay + 46), R16
//  687 					Time_delay.timer_takeline.time_out = 0;
        STS     (Time_delay + 45), R16
//  688 					Stop_allTimer();		//0520
        RCALL   Stop_allTimer
        RJMP    ??Check_SCS_received_29
//  689 				}
//  690 				else		
//  691 				{
//  692                                         // signal frame OFF
//  693 				}
//  694 			     break;
//  695 				
//  696 			 case Maintain_state:
//  697 				
//  698 				if(SCS_received.nopresence_2_OFF == 1)			//received no presence and OFF frame
??Check_SCS_received_31:
        LDD     R16, Z+1
        SBRS    R16, 7
        RJMP    ??Check_SCS_received_34
//  699 				{
//  700 					SCS_received.nopresence_2_OFF = 0;			
        LDD     R16, Z+1
        ANDI    R16, 0x7F
        STD     Z+1, R16
//  701 					Sensor_mode.flag_leader_group = 0;	
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xFD
        STD     Z+5, R16
//  702 					Time_delay.timer_takeline.enabled = 0;		// after received the frame no presence and OFF, stop the taking line
        LDI     R16, 0
        STS     (Time_delay + 46), R16
//  703 					Time_delay.timer_takeline.time_out = 0;			
        STS     (Time_delay + 45), R16
//  704 					Sensor_mode.mode_state = Standby_state;
        LDI     R16, 4
        STS     Sensor_mode, R16
//  705 					if(KO_conf.FuncMod != ManualON_Auto_OFF)	
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BREQ    ??Check_SCS_received_35
//  706 					  Time_delay.Re_Trigger_senconds = Re_Trigger_5s;
        LDI     R16, 5
??Check_SCS_received_36:
        STS     Time_delay, R16
        RJMP    ??Check_SCS_received_29
//  707 					else						
//  708 					  Time_delay.Re_Trigger_senconds = Re_Trigger_30s;	
??Check_SCS_received_35:
        LDI     R16, 30
        RJMP    ??Check_SCS_received_36
//  709 				}
//  710 				else				// signal frame OFF
//  711 				{
//  712 					if(Delay_Time_set > Walkthru_delay)		
??Check_SCS_received_34:
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 181
        LDI     R20, 0
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BRCS    ??Check_SCS_received_37
//  713 						Time_delay.Walk_Through_Timeout = Walkthru_delay;
        LDI     R16, 180
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R20
        RJMP    ??Check_SCS_received_38
//  714 					else									
//  715 						Time_delay.Walk_Through_Timeout = Delay_Time_set;
??Check_SCS_received_37:
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R17
//  716 					
//  717 					Walk_Through_flag = 1;
??Check_SCS_received_38:
        LDI     R16, 1
        STS     Walk_Through_flag, R16
//  718 					Time_delay.detect_waitting = 20000;		// 0601 detection is disabled 20s
        LDI     R16, 32
        LDI     R17, 78
        STD     Z+11, R16
        STD     Z+12, R17
//  719 					if(KO_conf.FuncMod == Auto_Walk_thru)
        LDS     R16, (KO_conf + 29)
        CPI     R16, 2
        BREQ    $+2+2
        RJMP    ??Check_SCS_received_29
//  720 						First_detection_enable = 0;
        STS     First_detection_enable, R20
        RJMP    ??Check_SCS_received_29
//  721 				}
//  722 			      break;
//  723 				
//  724 			  case Re_Trigger_State:	
//  725 					Walk_Through_flag = 1;
??Check_SCS_received_32:
        LDI     R16, 1
        STS     Walk_Through_flag, R16
//  726 					if(Delay_Time_set > Walkthru_delay)		
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 181
        LDI     R20, 0
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BRCS    ??Check_SCS_received_39
//  727 						Time_delay.Walk_Through_Timeout = Walkthru_delay;
        LDI     R16, 180
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R20
        RJMP    ??Check_SCS_received_40
//  728 					else									
//  729 						Time_delay.Walk_Through_Timeout = Delay_Time_set;	
??Check_SCS_received_39:
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R17
//  730 					
//  731 					Sensor_mode.mode_state = Maintain_state;
??Check_SCS_received_40:
        LDI     R16, 2
        STS     Sensor_mode, R16
//  732 					Time_delay.Re_Trigger_senconds = 0;
        STS     Time_delay, R20
//  733 					Time_delay.detect_waitting = 20000;		// 0601 detection is disabled 20s
        RJMP    ??Check_SCS_received_41
//  734 			      break;
//  735 				
//  736 			  case Standby_state:
//  737 				if(SCS_received.nopresence_2_OFF == 1)			// received no presence and OFF
??Check_SCS_received_33:
        LDD     R16, Z+1
        SBRS    R16, 7
        RJMP    ??Check_SCS_received_42
//  738 				{
//  739 					SCS_received.nopresence_2_OFF = 0;
        LDD     R16, Z+1
        ANDI    R16, 0x7F
        STD     Z+1, R16
//  740 					Sensor_mode.flag_leader_group = 0;				// this is no need, because Sensor_mode.flag_leader_group = 0
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xFD
        STD     Z+5, R16
//  741 
//  742 					Time_delay.timer_takeline.enabled = 0;		// after received the frame no presence and OFF, stop the taking line
        LDI     R16, 0
        STS     (Time_delay + 46), R16
//  743 					Time_delay.timer_takeline.time_out = 0;
        STS     (Time_delay + 45), R16
//  744 					Time_delay.timer_delay_set.enabled = 0;		// stop time set delay
        STS     (Time_delay + 35), R16
//  745 					Time_delay.timer_delay_set.time_out = 0;
        STS     (Time_delay + 34), R16
//  746 					Time_delay.Walk_Through_Timeout = 0;			// stop walk_through delay	
        LDI     R17, 0
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R16
//  747 						
//  748 					if(Walk_Through_flag == 1)
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BRNE    ??Check_SCS_received_43
//  749 					{
//  750 						Sensor_mode.mode_state = Initial_state;	
        LDI     R16, 1
        STS     Sensor_mode, R16
//  751 						Time_delay.timer_delay_set.time_out = 0;
        STS     (Time_delay + 34), R17
//  752 						Sensor_mode.no_prence_off_send = 0;			// allow to send no presence and OFF frame
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xDF
        STD     Z+5, R16
//  753 						Time_delay.Re_Trigger_senconds = 0;
        STS     Time_delay, R17
        RJMP    ??Check_SCS_received_29
//  754 					}
//  755 					else
//  756 					{
//  757 						Time_delay.Re_Trigger_senconds = Re_Trigger_5s;	
??Check_SCS_received_43:
        LDI     R16, 5
        STS     Time_delay, R16
//  758 						Sensor_mode.mode_state = Standby_state;		
        LDI     R16, 4
        STS     Sensor_mode, R16
        RJMP    ??Check_SCS_received_29
//  759 					}
//  760 				}
//  761 				else										// single OFF frame
//  762 				{
//  763 					Walk_Through_flag = 1;
??Check_SCS_received_42:
        LDI     R16, 1
        STS     Walk_Through_flag, R16
//  764 					if(Delay_Time_set > Walkthru_delay)		
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CPI     R16, 181
        LDI     R20, 0
        CPC     R17, R20
        CPC     R18, R20
        CPC     R19, R20
        BRCS    ??Check_SCS_received_44
//  765 						Time_delay.Walk_Through_Timeout = Walkthru_delay;
        LDI     R16, 180
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R20
        RJMP    ??Check_SCS_received_41
//  766 					else									
//  767 						Time_delay.Walk_Through_Timeout = Delay_Time_set;
??Check_SCS_received_44:
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        MOVW    R31:R30, R25:R24
        STD     Z+1, R16
        STD     Z+2, R17
//  768 					
//  769 					Time_delay.detect_waitting = 20000;		// 0601 detection is disabled 20s
??Check_SCS_received_41:
        LDI     R16, 32
        LDI     R17, 78
        STD     Z+11, R16
        STD     Z+12, R17
//  770 				}
//  771 			      break;
//  772 			
//  773 			  default:  break;				
//  774 		}
//  775 	}
//  776 	
//  777 //******************************************************************************
//  778 // 	if received GR "lux" request
//  779 //******************************************************************************	
//  780 
//  781 	if(SCS_received.modality_lux_request == 1)
??Check_SCS_received_29:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+3
        SBRS    R16, 1
        RJMP    ??Check_SCS_received_45
//  782 	{
//  783 		SCS_received.modality_lux_request = 0;
        LDD     R16, Z+3
        ANDI    R16, 0xFD
        STD     Z+3, R16
//  784 		frame_M2_answer('0');
        LDI     R16, 48
        CALL    frame_M2_answer
//  785 		
//  786 	}
//  787 	if(SCS_received.setpoint_high ==1)
??Check_SCS_received_45:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+3
        SBRS    R16, 5
        RJMP    ??Check_SCS_received_46
//  788 	{
//  789 	 	SCS_received.setpoint_high = 0;
        LDD     R16, Z+3
        ANDI    R16, 0xDF
        STD     Z+3, R16
//  790                 DLL_setpoint(3);//(High);
        LDI     R16, 3
        CALL    DLL_setpoint
//  791 	}
//  792     if(SCS_received.setpoint_medium ==1)
??Check_SCS_received_46:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+3
        SBRS    R16, 6
        RJMP    ??Check_SCS_received_47
//  793 	{
//  794 	 	SCS_received.setpoint_medium = 0;
        LDD     R16, Z+3
        ANDI    R16, 0xBF
        STD     Z+3, R16
//  795                 DLL_setpoint(2);//(Medium);
        LDI     R16, 2
        CALL    DLL_setpoint
//  796 	}
//  797 	if(SCS_received.setpoint_low ==1)
??Check_SCS_received_47:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+3
        SBRS    R16, 4
        RJMP    ??Check_SCS_received_48
//  798 	{
//  799 		 SCS_received.setpoint_low = 0;
        LDD     R16, Z+3
        ANDI    R16, 0xEF
        STD     Z+3, R16
//  800 		 DLL_setpoint(1);//(Low);
        LDI     R16, 1
        CALL    DLL_setpoint
//  801 	}
//  802 }
??Check_SCS_received_48:
        LDI     R30, 4
        JMP     ?EPILOGUE_B4_L09
        CFI EndBlock cfiBlock13
//  803 
//  804 
//  805 //******************************************************************************
//  806 // check the detection of Pir or US
//  807 // Pir warmup time should be at least 30s
//  808 // 6ms every cycle for Pir, 200us every cycle for US
//  809 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  810 void occupancy_detect(void)
occupancy_detect:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function occupancy_detect
//  811 {
        FUNCALL occupancy_detect, motion_detect
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL occupancy_detect, Dled_light_on_ms
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
//  812     //if((++Time_delay.timer0_compa_cnt >= 2)&&(Time_delay.pir_warmup_ok == 1))			// every 6ms
//  813 		if(Time_delay.pir_warmup_ok == 1)
        LDI     R26, LOW(Time_delay)
        LDI     R27, (Time_delay) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRS    R16, 0
        RJMP    ??occupancy_detect_0
//  814 		{
//  815 			Time_delay.timer0_compa_cnt = 0;
        LDI     R16, 0
        STD     Z+24, R16
        STD     Z+25, R16
//  816 			motion_resutl = 0;
        STS     motion_resutl, R16
//  817 			if(product_information.cen_system)
        LDS     R16, (product_information + 4)
        TST     R16
        BREQ    ??occupancy_detect_1
//  818 			{
//  819 				Sensor_mode.detect_scheme = KO_conf.DF;
        LDS     R16, (KO_conf + 22)
        STS     (Sensor_mode + 2), R16
//  820 			}
//  821 			motion_resutl = motion_detect(Sensor_mode.detect_scheme);   							// set in the files function mode.c
??occupancy_detect_1:
        LDS     R16, (Sensor_mode + 2)
        CALL    motion_detect
        STS     motion_resutl, R16
//  822 			motion_total = motion_total + motion_resutl;
        LDS     R16, motion_resutl
        LDI     R17, 0
        LDI     R30, LOW(motion_total)
        LDI     R31, (motion_total) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        ADD     R18, R16
        ADC     R19, R17
        ST      Z, R18
        STD     Z+1, R19
//  823 			if(motion_total)
        LDS     R16, motion_total
        LDS     R17, (motion_total + 1)
        OR      R16, R17
        BREQ    ??occupancy_detect_2
//  824 				asm("nop");
        nop
//  825 			if((motion_total)&&(SCS_received.calib_wait != 1)&&(Time_delay.pir_warmup_ok == 1)&&(Time_delay.detect_waitting ==0))			// in the calibration waitting mode, motion detection is disabled
??occupancy_detect_2:
        LDS     R16, motion_total
        LDS     R17, (motion_total + 1)
        OR      R16, R17
        BREQ    ??occupancy_detect_0
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+4
        SBRC    R16, 0
        RJMP    ??occupancy_detect_0
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRS    R16, 0
        RJMP    ??occupancy_detect_0
        LDD     R16, Z+11
        LDD     R17, Z+12
        OR      R16, R17
        BRNE    ??occupancy_detect_0
//  826 			{
//  827 				//DLED_ON;
//  828 				motion_total = 0;
        LDI     R16, 0
        STS     motion_total, R16
        STS     (motion_total + 1), R16
//  829 				Dled_light_on_ms(1000);
        LDI     R16, 232
        LDI     R17, 3
        LDI     R18, 0
        LDI     R19, 0
        CALL    Dled_light_on_ms
//  830 				//Time_delay.timer_1s.count = 0;							//start count 1 second	
//  831 				US_detection_en = 0;
        LDI     R16, 0
        STS     US_detection_en, R16
//  832 				PIR_detection_en = 0;
        STS     PIR_detection_en, R16
//  833 				SCS_received.motion_detect = 1;
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        ORI     R16, 0x40
        STD     Z+2, R16
//  834 				flags.motion_detected = 1;
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        ORI     R16, 0x02
        STD     Z+9, R17
        STD     Z+8, R16
//  835 				SetBit(KO_conf.status[0],Status_Detection);				//0515
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ORI     R16, 0x08
        STD     Z+45, R16
//  836 			}
//  837 		}
//  838 }
??occupancy_detect_0:
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock14
//  839 
//  840 
//  841 //******************************************************************************
//  842 // function LM GR  machine states	begin	
//  843 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
//  844 void _Initial_state(void)
_Initial_state:
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function _Initial_state
//  845 {			
        FUNCALL _Initial_state, Mode_frame_GR
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, frame_ON_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, Call_detect_delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, Start_Time_Delay
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, GS_presence_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, frame_OFF_send
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, ON_takeline
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Initial_state, OFF_takeline
        LOCFRAME CSTACK, 4, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        CALL    ?PROLOGUE4_L09
        CFI R27 Frame(CFA_Y, -1)
        CFI R26 Frame(CFA_Y, -2)
        CFI R25 Frame(CFA_Y, -3)
        CFI R24 Frame(CFA_Y, -4)
        CFI CFA_Y Y+4
//  846 	
//  847 	if(SCS_received.motion_detect == 1 && Sensor_mode.presence_20sinterval == 0)				// 0520	
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRS    R16, 6
        RJMP    ??_Initial_state_0
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+3
        LDD     R17, Z+4
        OR      R16, R17
        BREQ    $+2+2
        RJMP    ??_Initial_state_0
//  848 	{
//  849       Mode_frame_GR(KO_conf.GR,pre);			                 // send frame GR presence  B5 GG 1D 00
        LDI     R24, LOW(KO_conf)
        LDI     R25, (KO_conf) >> 8
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  850 			Sensor_mode.presence_send = 1;
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ORI     R16, 0x04
        STD     Z+5, R16
//  851 			
//  852 			if((KO_conf.KO_number == 119)||(KO_conf.KO_number == 168)&&(DLL.loadoff_level < set_point)&&(KO_conf.FuncMod != ManualON_Auto_OFF))
        MOVW    R31:R30, R25:R24
        LDD     R16, Z+47
        LDD     R17, Z+48
        CPI     R16, 119
        LDI     R18, 0
        CPC     R17, R18
        BREQ    ??_Initial_state_1
        LDD     R16, Z+47
        LDD     R17, Z+48
        CPI     R16, 168
        CPC     R17, R18
        BRNE    ??_Initial_state_2
        LDS     R16, (DLL + 10)
        LDS     R17, (DLL + 11)
        LDS     R18, set_point
        LDS     R19, (set_point + 1)
        CP      R16, R18
        CPC     R17, R19
        BRCC    ??_Initial_state_2
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BREQ    ??_Initial_state_2
//  853 			{
//  854 				//reyno 0622
//  855 				if(KO_conf.LightReg == 1)
??_Initial_state_1:
        LDS     R16, (KO_conf + 28)
        CPI     R16, 1
        BRNE    ??_Initial_state_3
//  856 				{
//  857 					DLL.start_regulation = 1;
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDD     R16, Z+54
        ORI     R16, 0x01
        STD     Z+54, R16
//  858 					SetBit(KO_conf.status[0],Status_Regulationing);
        MOVW    R31:R30, R25:R24
        LDD     R16, Z+45
        ORI     R16, 0x40
        STD     Z+45, R16
//  859 				}
//  860 				
//  861 				Sensor_mode.mode_state = Maintain_state;
??_Initial_state_3:
        LDI     R16, 2
        STS     Sensor_mode, R16
//  862 				Sensor_mode.motion_initial_detect = 1;			//保证第一次动initial进入到maintain时程序能正常的设定延迟时间		
        LDS     R16, (Sensor_mode + 7)
        ANDI    R16, 0xF3
        ORI     R16, 0x04
        STS     (Sensor_mode + 7), R16
//  863 				//SCS_received.motion_detect = 1;						//debug 0520
//  864 				Sensor_mode.flag_leader_group = 1;				
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ORI     R16, 0x02
        STD     Z+5, R16
//  865 				frame_ON_send();
        RCALL   frame_ON_send
//  866      	 	Call_detect_delay();
        RCALL   Call_detect_delay
        RJMP    ??_Initial_state_4
//  867 			}
//  868 			else
//  869 			{				
//  870 				Start_Time_Delay();
??_Initial_state_2:
        RCALL   Start_Time_Delay
//  871 			}	
//  872 			GS_presence_send();	
??_Initial_state_4:
        RCALL   GS_presence_send
//  873 		
//  874 			//	if(KO_conf.FuncMod == Auto_Walk_thru)			//0521
//  875 			//		Sensor_mode.motion_initial_detect = 2;	
//  876 			//	else
//  877 			Sensor_mode.presence_20sinterval = presence_20s;
        LDI     R16, 32
        LDI     R17, 78
        MOVW    R31:R30, R27:R26
        STD     Z+3, R16
        STD     Z+4, R17
//  878 		
//  879 	}
//  880 
//  881 	SCS_received.motion_detect = 0;
??_Initial_state_0:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
//  882 		
//  883 	if(Time_delay.timer_delay_set.time_out == 1)//&&(Sensor_mode.no_prence_off_send == 0))	//make sure send one no presence and OFF frame in initial state
        LDS     R16, (Time_delay + 34)
        CPI     R16, 1
        BRNE    ??_Initial_state_5
//  884 	{
//  885 		Time_delay.timer_delay_set.started = 0;
        LDI     R16, 0
        STS     (Time_delay + 36), R16
//  886 		Time_delay.timer_delay_set.time_out = 0;
        STS     (Time_delay + 34), R16
//  887 		
//  888 		//if(KO_conf.AddressType == PP)         //reyno 0709
//  889 			//Mode_frame_GR(KO_conf.GR,nopre);
//  890 		
//  891 		if(Sensor_mode.flag_leader_group == 1)
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        SBRS    R16, 1
        RJMP    ??_Initial_state_6
//  892 		{						
//  893 				//	Mode_frame_GR(KO_conf.GR,pre);
//  894 				frame_OFF_send();
        RCALL   frame_OFF_send
//  895 				Sensor_mode.no_prence_off_send = 1;					
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ORI     R16, 0x20
        STD     Z+5, R16
        RJMP    ??_Initial_state_5
//  896 		}
//  897 		else		//  WITH Special TAKING LINE : after send no presence+OFF帧后不再进入到这一步程序
//  898 		{
//  899 			Sensor_mode.OFF_takeline_waitsend = 1;						//	OFF_takeline();									
??_Initial_state_6:
        LDD     R16, Z+7
        ORI     R16, 0x02
        STD     Z+7, R16
//  900 		}		
//  901 	}
//  902 	
//  903 	if ((Sensor_mode.ON_takeline_waitsend == 1)||(Sensor_mode.OFF_takeline_waitsend == 1))
??_Initial_state_5:
        LDS     R16, (Sensor_mode + 7)
        ANDI    R16, 0x03
        BREQ    ??_Initial_state_7
//  904 	{
//  905 		if(Time_delay.timer_takeline.started == 0)						// start the timer_takeline
        LDS     R16, (Time_delay + 47)
        TST     R16
        BRNE    ??_Initial_state_8
//  906 		{
//  907 			Time_delay.timer_takeline.count = 0;
        LDI     R16, 0
        LDI     R30, LOW(Time_delay)
        LDI     R31, (Time_delay) >> 8
        STD     Z+37, R16
        STD     Z+38, R16
        STD     Z+39, R16
        STD     Z+40, R16
//  908 		//	Time_delay.timer_takeline.time_out = 0;
//  909 			Time_delay.timer_takeline.enabled = 1;
        LDI     R16, 1
        STS     (Time_delay + 46), R16
//  910 			Time_delay.timer_takeline.started = 1;
        STS     (Time_delay + 47), R16
//  911 			Time_delay.random_time	= Sensor_mode.random_takeline*400;	// random time delay for the frame send	
        LDS     R20, (Sensor_mode + 6)
        LDI     R21, 0
        LDI     R16, 144
        LDI     R17, 1
        CALL    ?S_EC_MUL_L02
        STD     Z+4, R16
        STD     Z+5, R17
//  912 		}
//  913 		if(Sensor_mode.ON_takeline_waitsend == 1) 		ON_takeline();
??_Initial_state_8:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRC    R16, 0
        RCALL   ON_takeline
//  914 		if(Sensor_mode.OFF_takeline_waitsend == 1)		OFF_takeline();		
??_Initial_state_9:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRC    R16, 1
        RCALL   OFF_takeline
//  915 	}	
//  916 }
??_Initial_state_7:
        LDI     R30, 4
        JMP     ?EPILOGUE_B4_L09
        CFI EndBlock cfiBlock15
//  917 
//  918 
//  919 

        RSEG CODE:CODE:NOROOT(1)
//  920 void _Maintain_state(void)
_Maintain_state:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function _Maintain_state
//  921 {			
        FUNCALL _Maintain_state, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, Start_Time_Delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, WT_20s_detect
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, GS_presence_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, WT_20s_detect
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, frame_OFF_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, Stop_allTimer
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, frame_OFF_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Maintain_state, Delay_Alert
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
//  922 	if(Sensor_mode.presence_20sinterval == 0)
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+3
        LDD     R17, Z+4
        OR      R16, R17
        BREQ    $+2+2
        RJMP    ??_Maintain_state_0
//  923 	{
//  924 		if(Sensor_mode.presen_timeout ==1)			// end detection
        LDD     R16, Z+5
        SBRS    R16, 3
        RJMP    ??_Maintain_state_1
//  925 		{
//  926 				Sensor_mode.presen_timeout = 0;
        LDD     R16, Z+5
        ANDI    R16, 0xF7
        STD     Z+5, R16
//  927 				SCS_received.motion_detect = 0;			//Ignore detection
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
//  928 				if(Walk_Through_flag != 1)
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BREQ    ??_Maintain_state_1
//  929 				{
//  930 						Mode_frame_GR(KO_conf.GR,pre);
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  931 						Start_Time_Delay();
        RCALL   Start_Time_Delay
//  932 				}
//  933 		}
//  934 		
//  935 		if((SCS_received.motion_detect == 1)||(Sensor_mode.motion_initial_detect != 0)||(Sensor_mode.maintain_pre == 1))		
??_Maintain_state_1:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRC    R16, 6
        RJMP    ??_Maintain_state_2
        LDS     R16, (Sensor_mode + 7)
        ANDI    R16, 0x1C
        BREQ    ??_Maintain_state_0
//  936 		{
//  937 			Sensor_mode.maintain_pre = 0;
??_Maintain_state_2:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        ANDI    R16, 0xEF
        STD     Z+7, R16
//  938 			if(Sensor_mode.motion_initial_detect ==0 && SCS_received.motion_detect != 1)					// detection in the maintain state
        LDS     R16, (Sensor_mode + 7)
        ANDI    R16, 0x0C
        BRNE    ??_Maintain_state_3
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRC    R16, 6
        RJMP    ??_Maintain_state_3
//  939 			{
//  940 				WT_20s_detect();
        RCALL   WT_20s_detect
//  941 				Mode_frame_GR(KO_conf.GR,pre);
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  942 			}
//  943 			else if(Sensor_mode.motion_initial_detect == 1)			// automatic just from initial to maintain
//  944 			{
//  945 			//	Sensor_mode.motion_initial_detect = 0;
//  946 			//	SCS_received.motion_detect =0;
//  947 			//	Mode_frame_GR(KO_conf.GR,pre);	
//  948 			}
//  949 			else if(Sensor_mode.motion_initial_detect == 2)			// W_T just from initial to maintain
//  950 			{
//  951 				//Sensor_mode.motion_initial_detect =0;
//  952 				//SCS_received.motion_detect =0;
//  953 			}
//  954 			
//  955 			if(SCS_received.motion_detect == 1)
??_Maintain_state_3:
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRS    R16, 6
        RJMP    ??_Maintain_state_0
//  956 			{
//  957 				Sensor_mode.presence_20sinterval = presence_20s; 	
        LDI     R16, 32
        LDI     R17, 78
        MOVW    R31:R30, R27:R26
        STD     Z+3, R16
        STD     Z+4, R17
//  958 				SCS_received.motion_detect = 0;	
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
//  959 				Mode_frame_GR(KO_conf.GR,pre);
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
//  960 				GS_presence_send();	
        RCALL   GS_presence_send
//  961 				WT_20s_detect();
        RCALL   WT_20s_detect
??_Maintain_state_0:
        LDS     R16, (Time_delay + 34)
        CPI     R16, 1
        BRNE    ??_Maintain_state_4
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BREQ    ??_Maintain_state_4
//  962 			}
//  963 		}
//  964 	}
//  965 	// end of load Time_dalay_count
//  966 	if((Time_delay.timer_delay_set.time_out == 1)&&(Walk_Through_flag != 1))	//sensor will then go into Re_Trigger_State
//  967 	{	
//  968 		Sensor_mode.end_dection = 0;						
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xEF
        STD     Z+5, R16
//  969 		Sensor_mode.mode_state = Re_Trigger_State;
        LDI     R16, 3
        STS     Sensor_mode, R16
//  970 		Time_delay.Re_Trigger_senconds = Re_Trigger_5s;
        LDI     R16, 5
        STS     Time_delay, R16
//  971 
//  972 		if(KO_conf.FuncMod == ManualON_Auto_OFF)//((KO_conf.FuncMod == ManualON_Auto_OFF)||(KO_conf.FuncMod == ManualON_Manual_OFF))
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BRNE    ??_Maintain_state_5
//  973 		{
//  974 			Time_delay.Re_Trigger_senconds = Re_Trigger_30s;
        LDI     R16, 30
        STS     Time_delay, R16
//  975 		}
//  976 		frame_OFF_send();
??_Maintain_state_5:
        RCALL   frame_OFF_send
//  977 		Sensor_mode.no_prence_off_send = 1;		//reyno 0619
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ORI     R16, 0x20
        STD     Z+5, R16
//  978 	}
//  979 	
//  980 	// end of Walk_Through_Timeout_count
//  981 	if((Time_delay.Walk_Through_Timeout ==0)&&(Walk_Through_flag == 1))	        // 处于	Walk_Through mode
??_Maintain_state_4:
        LDS     R16, (Time_delay + 1)
        LDS     R17, (Time_delay + 2)
        OR      R16, R17
        BRNE    ??_Maintain_state_6
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BRNE    ??_Maintain_state_6
//  982 	{
//  983 		Sensor_mode.end_dection = 0;						
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xEF
        STD     Z+5, R16
//  984 		Sensor_mode.mode_state = Initial_state;				// if in Walk_Through mode, the sensor won't go to Retrigger state
        LDI     R16, 1
        STS     Sensor_mode, R16
//  985 		Time_delay.timer_delay_set.time_out = 0;
        LDI     R16, 0
        STS     (Time_delay + 34), R16
//  986 		Sensor_mode.no_prence_off_send = 0;					// allow to send no presence and OFF frame again in initial state
        LDD     R16, Z+5
        ANDI    R16, 0xDF
        STD     Z+5, R16
//  987 		Stop_allTimer();
        RCALL   Stop_allTimer
//  988 		if(First_detection_enable == 1)
        LDS     R16, First_detection_enable
        CPI     R16, 1
        BRNE    ??_Maintain_state_6
//  989 		{
//  990 			First_detection_enable = 0;	
        LDI     R16, 0
        STS     First_detection_enable, R16
//  991 			frame_OFF_send();
        RCALL   frame_OFF_send
//  992 			Sensor_mode.no_prence_off_send = 1;		//reyno 0619
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ORI     R16, 0x20
        STD     Z+5, R16
//  993     }
//  994 	}
//  995 	
//  996 	Delay_Alert();										
??_Maintain_state_6:
        RCALL   Delay_Alert
//  997 }
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock16
//  998 
//  999 

        RSEG CODE:CODE:NOROOT(1)
// 1000 void _ReTrigger_State(void)
_ReTrigger_State:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function _ReTrigger_State
// 1001 {
        FUNCALL _ReTrigger_State, Start_Time_Delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _ReTrigger_State, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _ReTrigger_State, frame_ON_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _ReTrigger_State, GS_presence_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _ReTrigger_State, Stop_allTimer
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
        LDS     R16, Time_delay
        TST     R16
        BREQ    ??_ReTrigger_State_0
// 1002 	//reyno 0609
// 1003 	//if(Time_delay.Re_Trigger_senconds >0 && Sensor_mode.detect_scheme != 0)					// Re_Trigger_time out is not over        0714
// 1004 	if(Time_delay.Re_Trigger_senconds >0 )					// Re_Trigger_time out is not over
// 1005 	{	
// 1006 		if(SCS_received.motion_detect == 1)
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRS    R16, 6
        RJMP    ??_ReTrigger_State_1
// 1007 		{
// 1008 			SCS_received.motion_detect = 0;			
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
// 1009 			Sensor_mode.mode_state = Maintain_state;
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        LDI     R16, 2
        STS     Sensor_mode, R16
// 1010 			Time_delay.Re_Trigger_senconds = 0;				
        LDI     R16, 0
        STS     Time_delay, R16
// 1011 			Start_Time_Delay();													// 回到maintain前，要重新开始计时延迟			
        RCALL   Start_Time_Delay
// 1012 			Mode_frame_GR(KO_conf.GR,pre);	        		// send GR frame presence;			
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
// 1013 			frame_ON_send();			
        RCALL   frame_ON_send
// 1014 			GS_presence_send();		
        RCALL   GS_presence_send
// 1015 			Sensor_mode.presence_20sinterval = presence_20s; 	 //  0514
        LDI     R16, 32
        LDI     R17, 78
        ADIW    R27:R26, 3
        ST      X+, R16
        ST      X, R17
        RJMP    ??_ReTrigger_State_1
// 1016 		}	
// 1017 	}
// 1018 	else			// retrigger timeout
// 1019 	{	
// 1020 		Sensor_mode.mode_state = Initial_state;
??_ReTrigger_State_0:
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        LDI     R16, 1
        STS     Sensor_mode, R16
// 1021 		Sensor_mode.no_prence_off_send = 0;					// allow to send no presence and OFF frame again in initial state
        ADIW    R27:R26, 5
        LD      R16, X
        ANDI    R16, 0xDF
        ST      X, R16
        SBIW    R27:R26, 5
// 1022 		Time_delay.timer_delay_set.time_out = 0;
        LDI     R16, 0
        STS     (Time_delay + 34), R16
// 1023 		if(KO_conf.FuncMod == ManualON_Auto_OFF)	Sensor_mode.manual_on_need = 1;	//在manual mode,retriggertimeout后，必需手动才能打开负载	
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BRNE    ??_ReTrigger_State_2
        ADIW    R27:R26, 5
        LD      R16, X
        ORI     R16, 0x40
        ST      X, R16
// 1024 		Stop_allTimer();
??_ReTrigger_State_2:
        RCALL   Stop_allTimer
// 1025 	}
// 1026 }
??_ReTrigger_State_1:
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock17
// 1027 
// 1028 

        RSEG CODE:CODE:NOROOT(1)
// 1029 void _Standby_state(void)
_Standby_state:
        CFI Block cfiBlock18 Using cfiCommon0
        CFI Function _Standby_state
// 1030 {			
        FUNCALL _Standby_state, Start_Time_Delay
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Standby_state, WT_20s_detect
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Standby_state, Mode_frame_GR
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Standby_state, GS_presence_send
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL _Standby_state, Stop_allTimer
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
// 1031 	
// 1032 	if(Sensor_mode.presen_timeout ==1)			// end detection
        LDI     R26, LOW(Sensor_mode)
        LDI     R27, (Sensor_mode) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        SBRS    R16, 3
        RJMP    ??_Standby_state_0
// 1033 		{
// 1034 				Sensor_mode.presen_timeout = 0;
        LDD     R16, Z+5
        ANDI    R16, 0xF7
        STD     Z+5, R16
// 1035 				//Mode_frame_GR(KO_conf.GR,pre);
// 1036 				SCS_received.motion_detect = 0;			//Ignore detection
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
// 1037 				Start_Time_Delay();
        RCALL   Start_Time_Delay
// 1038 		}
// 1039 	
// 1040 	if(Sensor_mode.presence_20sinterval == 0)					
??_Standby_state_0:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+3
        LDD     R17, Z+4
        OR      R16, R17
        BRNE    ??_Standby_state_1
// 1041 	{		
// 1042 		if(SCS_received.motion_detect == 1)				
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        SBRS    R16, 6
        RJMP    ??_Standby_state_1
// 1043 		{
// 1044 			SCS_received.motion_detect = 0;
        LDD     R16, Z+2
        ANDI    R16, 0xBF
        STD     Z+2, R16
// 1045      	Sensor_mode.presence_20sinterval = presence_20s; 		
        LDI     R16, 32
        LDI     R17, 78
        MOVW    R31:R30, R27:R26
        STD     Z+3, R16
        STD     Z+4, R17
// 1046 			WT_20s_detect();
        RCALL   WT_20s_detect
// 1047 			Mode_frame_GR(KO_conf.GR,pre);						// send GR frame presence;
        LDI     R17, 3
        LDS     R16, (KO_conf + 6)
        CALL    Mode_frame_GR
// 1048 			GS_presence_send();	
        RCALL   GS_presence_send
// 1049 		}
// 1050 	}
// 1051 	
// 1052 	if((Time_delay.timer_delay_set.time_out ==1)||(Time_delay.Re_Trigger_senconds ==1)||(Time_delay.Walk_Through_Timeout ==1))	
??_Standby_state_1:
        LDI     R30, LOW(Time_delay)
        LDI     R31, (Time_delay) >> 8
        LDD     R16, Z+34
        CPI     R16, 1
        BREQ    ??_Standby_state_2
        LD      R16, Z
        CPI     R16, 1
        BREQ    ??_Standby_state_2
        LDD     R16, Z+1
        LDD     R17, Z+2
        CPI     R16, 1
        LDI     R18, 0
        CPC     R17, R18
        BRNE    ??_Standby_state_3
// 1053 	{		
// 1054 		Sensor_mode.mode_state = Initial_state;
??_Standby_state_2:
        LDI     R16, 1
        STS     Sensor_mode, R16
// 1055 		Time_delay.timer_delay_set.time_out = 0;
        LDI     R16, 0
        STD     Z+34, R16
// 1056 		Sensor_mode.no_prence_off_send = 0;			        	// allow to send no presence and OFF frame again in initial state
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+5
        ANDI    R16, 0xDF
        STD     Z+5, R16
// 1057 		Stop_allTimer();																	// stop all timer
        RCALL   Stop_allTimer
// 1058 	}
// 1059 	// end of Regulation_Timeout_count
// 1060 }
??_Standby_state_3:
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock18
// 1061 
// 1062 
// 1063 //******************************************************************************
// 1064 // function for LM GR with addressed type==2
// 1065 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
// 1066 void Function_LM_GR(void)
Function_LM_GR:
        CFI Block cfiBlock19 Using cfiCommon0
        CFI Function Function_LM_GR
// 1067 {
// 1068 		function_check_status();             					//respond the frames according to its own state
        FUNCALL Function_LM_GR, function_check_status
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_LM_GR, _Initial_state
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_LM_GR, _Maintain_state
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_LM_GR, _ReTrigger_State
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_LM_GR, _Standby_state
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        RCALL   function_check_status
        LDS     R16, (Sensor_mode + 6)
        INC     R16
        STS     (Sensor_mode + 6), R16
        LDS     R16, (Sensor_mode + 6)
        CPI     R16, 11
        BRCS    ??Function_LM_GR_0
// 1069 
// 1070 		if(1)//(Sensor_mode.manual_on_need !=1)					//((Sensor_mode.manual_on_need !=1)&&(KO_conf.FuncMod != ManualON_Manual_OFF))	
// 1071 		{														// 在manual mode,retrigger timeout后，必需手动才能打开负载
// 1072 			if(++Sensor_mode.random_takeline > 10)	
// 1073 			  	Sensor_mode.random_takeline = 1;				// used for random taking line
        LDI     R16, 1
        STS     (Sensor_mode + 6), R16
// 1074 			if(Walk_Through_flag == 1)	
??Function_LM_GR_0:
        LDS     R16, Walk_Through_flag
        CPI     R16, 1
        BRNE    ??Function_LM_GR_1
// 1075 			  	SetBit(KO_conf.status[0],Status_Walk_through);
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+45
        ORI     R16, 0x02
        STD     Z+45, R16
// 1076       switch(Sensor_mode.mode_state)
??Function_LM_GR_1:
        LDS     R16, Sensor_mode
        SUBI    R16, 1
        BREQ    ??Function_LM_GR_2
        DEC     R16
        BREQ    ??Function_LM_GR_3
        DEC     R16
        BREQ    ??Function_LM_GR_4
        DEC     R16
        BREQ    ??Function_LM_GR_5
        RET
// 1077 			{	
// 1078 				case Initial_state:	
// 1079           Sensor_mode.detect_scheme = KO_conf.InitOccu;
??Function_LM_GR_2:
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+30
        STS     (Sensor_mode + 2), R16
// 1080 					KO_conf.status[0] &= 0xF8;
        LDD     R16, Z+45
        ANDI    R16, 0xF8
        STD     Z+45, R16
// 1081 					_Initial_state();
        RCALL   _Initial_state
        RET
// 1082 					break;
// 1083 				case Maintain_state:
// 1084           Sensor_mode.detect_scheme = KO_conf.MaintainOccu;
??Function_LM_GR_3:
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+31
        STS     (Sensor_mode + 2), R16
// 1085 					SetBit(KO_conf.status[0],Status_Maintain);
        LDD     R16, Z+45
        ORI     R16, 0x04
        STD     Z+45, R16
// 1086 					ClrBit(KO_conf.status[0],Status_Retrigger);
        LDD     R16, Z+45
        ANDI    R16, 0xFE
        STD     Z+45, R16
// 1087 					_Maintain_state();
        RCALL   _Maintain_state
        RET
// 1088 					break;
// 1089 				case Re_Trigger_State:
// 1090           Sensor_mode.detect_scheme = KO_conf.Retrigger;
??Function_LM_GR_4:
        LDI     R30, LOW(KO_conf)
        LDI     R31, (KO_conf) >> 8
        LDD     R16, Z+32
        STS     (Sensor_mode + 2), R16
// 1091 					ClrBit(KO_conf.status[0],Status_Maintain);
        LDD     R16, Z+45
        ANDI    R16, 0xFB
        STD     Z+45, R16
// 1092 					SetBit(KO_conf.status[0],Status_Retrigger);
        LDD     R16, Z+45
        ORI     R16, 0x01
        STD     Z+45, R16
// 1093 					_ReTrigger_State();
        RCALL   _ReTrigger_State
        RET
// 1094 					break;
// 1095 				case Standby_state:
// 1096 					_Standby_state();
??Function_LM_GR_5:
        RCALL   _Standby_state
// 1097 					break;
// 1098 				default: break;				
// 1099 			}
// 1100 		}
// 1101 		//if(Sensor_mode.flag_leader_group == 1)		
// 1102 		//LLED_ON ;
// 1103 		//else							
// 1104 		//LLED_OFF ;
// 1105 }
        RET
        CFI EndBlock cfiBlock19
// 1106 
// 1107 /////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1108 //////////////////		LM GR  machine states	end		/////////////////////////////////////////////////
// 1109 /////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1110 
// 1111 //******************************************************************************
// 1112 // function for KO119
// 1113 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
// 1114 void Function_KO119(void)	// Stand-alone motion sensor
Function_KO119:
        CFI Block cfiBlock20 Using cfiCommon0
        CFI Function Function_KO119
// 1115 {
// 1116 	set_point = 0xFFFF;
        FUNCALL Function_KO119, occupancy_detect
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO119, Function_LM_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO119, Light_regulation
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        LDI     R16, 255
        STS     set_point, R16
        STS     (set_point + 1), R16
// 1117 	DLL.current_level = 0;
        LDI     R30, LOW(DLL)
        LDI     R31, (DLL) >> 8
        LDI     R16, 0
        STD     Z+16, R16
        STD     Z+17, R16
// 1118 	DLL.calc_level = 0;
        STD     Z+18, R16
        STD     Z+19, R16
// 1119 	
// 1120 	occupancy_detect();
        RCALL   occupancy_detect
// 1121 	Function_LM_GR();	// Function_LM_GR(168);
        RCALL   Function_LM_GR
// 1122 	Light_regulation();
        CALL    Light_regulation
// 1123 }
        RET
        CFI EndBlock cfiBlock20
// 1124 
// 1125 //******************************************************************************
// 1126 // function for KO128
// 1127 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
// 1128 void Function_KO128(void)								// Daylight and motion sensor for centralized LM system
Function_KO128:
        CFI Block cfiBlock21 Using cfiCommon0
        CFI Function Function_KO128
// 1129 {
        FUNCALL Function_KO128, timer_interval_initial
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, read_adc10bit
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, configuration_answer_frame
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, timer_5m_initial
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, timer_5m_initial
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, configuration_answer_frame
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, occupancy_detect
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, frame_presence
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, relay_timer_initial
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, Start_Time_Delay
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, frame_presence
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, relay_timer_initial
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO128, Start_Time_Delay
        LOCFRAME CSTACK, 12, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        CALL    ?PROLOGUE12_L09
        CFI R11 Frame(CFA_Y, -1)
        CFI R10 Frame(CFA_Y, -2)
        CFI R9 Frame(CFA_Y, -3)
        CFI R8 Frame(CFA_Y, -4)
        CFI R7 Frame(CFA_Y, -5)
        CFI R6 Frame(CFA_Y, -6)
        CFI R5 Frame(CFA_Y, -7)
        CFI R4 Frame(CFA_Y, -8)
        CFI R27 Frame(CFA_Y, -9)
        CFI R26 Frame(CFA_Y, -10)
        CFI R25 Frame(CFA_Y, -11)
        CFI R24 Frame(CFA_Y, -12)
        CFI CFA_Y Y+12
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        REQUIRE ?Register_R11_is_cg_reg
// 1130 	//daylight_service();
// 1131 	//get_dl_level();
// 1132 	unsigned long int temp_lux = 0;
        LDI     R24, 0
        LDI     R25, 0
        LDI     R26, 0
        LDI     R27, 0
// 1133 	unsigned char i;
// 1134 	
// 1135 	if( Time_delay.sample_interval.time_out )
        LDS     R16, (Time_delay + 311)
        TST     R16
        BRNE    $+2+2
        RJMP    ??Function_KO128_0
// 1136 	{
// 1137 		timer_interval_initial(1000);
        LDI     R16, 232
        LDI     R17, 3
        LDI     R18, 0
        LDI     R19, 0
        RCALL   timer_interval_initial
// 1138 		DLL.day_level = read_adc10bit ( daylight_channel );		// ADC value
        LDI     R16, LOW(DLL)
        MOV     R4, R16
        LDI     R16, (DLL) >> 8
        MOV     R5, R16
        LDI     R16, 3
        CALL    read_adc10bit
        MOVW    R31:R30, R5:R4
        STD     Z+6, R16
        STD     Z+7, R17
// 1139 #ifdef SMT
// 1140 	DLL.read_lux = exp10(5 * (double)(DLL.day_level)/1024 * 100000 / RES_VALUE);
// 1141 	DLL.calc_level = (unsigned int)DLL.read_lux ;
// 1142 #else
// 1143 	//DLL.calc_level = (CONST_DAYLIGHT * (unsigned long)DLL.day_level)/100;									// calculate the daylight level (LUX)around the sensor
// 1144 	DLL.calc_level = (unsigned int)(g_slope * (double)DLL.day_level);
        LDD     R16, Z+6
        LDD     R17, Z+7
        LDI     R18, 0
        LDI     R19, 0
        CALL    ?UL2F_L04
        LDI     R30, LOW(g_slope)
        LDI     R31, (g_slope) >> 8
        LD      R20, Z
        LDD     R21, Z+1
        LDD     R22, Z+2
        LDD     R23, Z+3
        CALL    ?F_MUL_L04
        CALL    ?F2SL_L04
        MOVW    R31:R30, R5:R4
        STD     Z+18, R16
        STD     Z+19, R17
// 1145 #endif
// 1146 		DLL.lux_array[DLL.daylight_SampleCount++] = DLL.calc_level;
        LDS     R16, (DLL + 1)
        MOV     R17, R16
        INC     R17
        STS     (DLL + 1), R17
        LDD     R18, Z+18
        LDD     R19, Z+19
        LDI     R17, 2
        MUL     R16, R17
        ADD     R30, R0
        ADC     R31, R1
        STD     Z+55, R18
        STD     Z+56, R19
// 1147 		
// 1148 		if(DLL.daylight_SampleCount >= SAMPLE_COUNT)
        LDS     R16, (DLL + 1)
        CPI     R16, 80
        BRCS    ??Function_KO128_1
// 1149 		{
// 1150 			DLL.daylight_SampleCount = 0;
        STS     (DLL + 1), R24
// 1151 			flags.KO_128_first_sampel_ready = 1;
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+12
        LDD     R17, Z+13
        ORI     R16, 0x10
        STD     Z+13, R17
        STD     Z+12, R16
// 1152 		}
// 1153 		
// 1154 		if(flags.KO_128_first_sampel_ready)
??Function_KO128_1:
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+12
        LDD     R17, Z+13
        SBRS    R16, 4
        RJMP    ??Function_KO128_2
// 1155 		{
// 1156 			#ifdef DEMOBOARD
// 1157 					ClrBit(PORTB,0);
// 1158 			#endif
// 1159 					
// 1160 			for(i=0;i<SAMPLE_COUNT;i++)
        LDI     R16, 0
        RJMP    ??Function_KO128_3
// 1161 			{
// 1162 				temp_lux += DLL.lux_array[i];
??Function_KO128_4:
        LDI     R17, 2
        MUL     R16, R17
        MOVW    R31:R30, R5:R4
        ADD     R30, R0
        ADC     R31, R1
        LDD     R20, Z+55
        LDD     R21, Z+56
        LDI     R22, 0
        ADD     R24, R20
        ADC     R25, R21
        ADC     R26, R22
        ADC     R27, R22
// 1163 			}
        INC     R16
??Function_KO128_3:
        CPI     R16, 80
        BRCS    ??Function_KO128_4
// 1164 			temp_lux /= SAMPLE_COUNT;
        LDI     R20, 80
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        CALL    ?UL_DIVMOD_L03
// 1165 			if(DLL.calc_level > temp_lux * 1.03 || DLL.calc_level < temp_lux * 0.97)
        CALL    ?UL2F_L04
        MOVW    R25:R24, R17:R16
        MOVW    R27:R26, R19:R18
        LDI     R20, 10
        LDI     R21, 215
        LDI     R22, 131
        LDI     R23, 63
        CALL    ?F_MUL_L04
        MOVW    R9:R8, R17:R16
        MOVW    R11:R10, R19:R18
        MOVW    R31:R30, R5:R4
        LDD     R16, Z+18
        LDD     R17, Z+19
        LDI     R18, 0
        LDI     R19, 0
        CALL    ?UL2F_L04
        MOVW    R21:R20, R17:R16
        MOVW    R23:R22, R19:R18
        MOVW    R17:R16, R9:R8
        MOVW    R19:R18, R11:R10
        CALL    ?F_CMP_LT_L04
        BRCS    ??Function_KO128_5
        MOVW    R31:R30, R5:R4
        LDD     R16, Z+18
        LDD     R17, Z+19
        LDI     R18, 0
        LDI     R19, 0
        CALL    ?UL2F_L04
        MOVW    R9:R8, R17:R16
        MOVW    R11:R10, R19:R18
        LDI     R20, 236
        LDI     R21, 81
        LDI     R22, 120
        LDI     R23, 63
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        CALL    ?F_MUL_L04
        MOVW    R21:R20, R17:R16
        MOVW    R23:R22, R19:R18
        MOVW    R17:R16, R9:R8
        MOVW    R19:R18, R11:R10
        CALL    ?F_CMP_LT_L04
        BRCC    ??Function_KO128_2
// 1166 			{
// 1167 				configuration_answer_frame(0x10);
??Function_KO128_5:
        LDI     R16, 16
        CALL    configuration_answer_frame
// 1168 				for(i=0;i<SAMPLE_COUNT;i++)
        LDI     R16, 0
        RJMP    ??Function_KO128_6
// 1169 				{
// 1170 					DLL.lux_array[i] = DLL.calc_level;
??Function_KO128_7:
        MOVW    R31:R30, R5:R4
        LDD     R18, Z+18
        LDD     R19, Z+19
        LDI     R17, 2
        MUL     R16, R17
        ADD     R30, R0
        ADC     R31, R1
        STD     Z+55, R18
        STD     Z+56, R19
// 1171 				}
        INC     R16
??Function_KO128_6:
        CPI     R16, 80
        BRCS    ??Function_KO128_7
// 1172 				timer_5m_initial(MIN_5);
        LDI     R16, 224
        LDI     R17, 147
        LDI     R18, 4
        LDI     R19, 0
        RCALL   timer_5m_initial
// 1173 			}
// 1174 			temp_lux = 0;
// 1175 			
// 1176 			#ifdef DEMOBOARD
// 1177 				SetBit(PORTB,0);
// 1178 			#endif
// 1179 		}
// 1180 		
// 1181 		if( Time_delay.timer_5m.time_out )
??Function_KO128_2:
        LDS     R16, (Time_delay + 80)
        TST     R16
        BREQ    ??Function_KO128_0
// 1182 		{
// 1183 			timer_5m_initial(MIN_5);
        LDI     R16, 224
        LDI     R17, 147
        LDI     R18, 4
        LDI     R19, 0
        RCALL   timer_5m_initial
// 1184 		  configuration_answer_frame(0x10);
        LDI     R16, 16
        CALL    configuration_answer_frame
// 1185 		}
// 1186 	}
// 1187 
// 1188 	if(Time_delay.relay.time_out)
??Function_KO128_0:
        LDS     R16, (Time_delay + 300)
        TST     R16
        BREQ    ??Function_KO128_8
// 1189   	occupancy_detect();
        RCALL   occupancy_detect
// 1190 	
// 1191 	if(flags.motion_detected && (flags.timer_started == 0 || Time_delay.timer_delay_set.time_out))
??Function_KO128_8:
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        SBRS    R16, 1
        RJMP    ??Function_KO128_9
        LDD     R16, Z+8
        LDD     R17, Z+9
        SBRS    R16, 2
        RJMP    ??Function_KO128_10
        LDS     R16, (Time_delay + 34)
        TST     R16
        BREQ    ??Function_KO128_9
// 1192 	{
// 1193 		flags.motion_detected = 0;
??Function_KO128_10:
        LDD     R16, Z+8
        LDD     R17, Z+9
        ANDI    R16, 0xFD
        STD     Z+9, R17
        STD     Z+8, R16
// 1194 		frame_presence('0');
        LDI     R16, 48
        CALL    frame_presence
// 1195 		relay_timer_initial(2000);
        LDI     R16, 208
        LDI     R17, 7
        LDI     R18, 0
        LDI     R19, 0
        CALL    relay_timer_initial
// 1196 		Start_Time_Delay();
        CALL    Start_Time_Delay
// 1197 		flags.timer_started = 1;
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        ORI     R16, 0x04
        STD     Z+9, R17
        STD     Z+8, R16
// 1198 	}
// 1199 	
// 1200 	if(Time_delay.timer_delay_set.time_out && flags.M2_step2_started == 0)
??Function_KO128_9:
        LDS     R16, (Time_delay + 34)
        TST     R16
        BREQ    ??Function_KO128_11
        LDD     R16, Z+12
        LDD     R17, Z+13
        SBRC    R16, 1
        RJMP    ??Function_KO128_11
// 1201 	{
// 1202 		//Time_delay.timer_delay_set.time_out = 0;
// 1203 		//flags.timer_started = 0;
// 1204 		flags.M2_step2_started = 1;
        LDD     R16, Z+12
        LDD     R17, Z+13
        ORI     R16, 0x02
        STD     Z+13, R17
        STD     Z+12, R16
// 1205 		if(flags.motion_detected)
        LDD     R16, Z+8
        LDD     R17, Z+9
        SBRS    R16, 1
        RJMP    ??Function_KO128_11
// 1206 		{
// 1207 			frame_presence('0');
        LDI     R16, 48
        CALL    frame_presence
// 1208 			relay_timer_initial(2000);
        LDI     R16, 208
        LDI     R17, 7
        LDI     R18, 0
        LDI     R19, 0
        CALL    relay_timer_initial
// 1209 			Start_Time_Delay();
        CALL    Start_Time_Delay
// 1210 		}
// 1211 	}
// 1212 }
??Function_KO128_11:
        LDI     R30, 12
        JMP     ?EPILOGUE_B12_L09
        CFI EndBlock cfiBlock21
// 1213 
// 1214 //******************************************************************************
// 1215 // function for KO166
// 1216 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
// 1217 void Function_KO166(char addrestype, char detectype, char LightReg)
Function_KO166:
        CFI Block cfiBlock22 Using cfiCommon0
        CFI Function Function_KO166
// 1218 {
// 1219 	
// 1220 }
        RET
        CFI EndBlock cfiBlock22
// 1221 

        RSEG CODE:CODE:NOROOT(1)
// 1222 void Function_KO164(void)
Function_KO164:
        CFI Block cfiBlock23 Using cfiCommon0
        CFI Function Function_KO164
// 1223 {
        FUNCALL Function_KO164, get_dl_level
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
// 1224 	get_dl_level();
        CALL    get_dl_level
// 1225 #ifdef SMT
// 1226 	DLL.read_lux = exp10(5 * (double)(DLL.day_level)/1024 * 100000 / RES_VALUE);
// 1227 	DLL.calc_level = (unsigned int)DLL.read_lux ;
// 1228 #else
// 1229 	//DLL.calc_level = (CONST_DAYLIGHT * (unsigned long)DLL.day_level)/100;									// calculate the daylight level (LUX)around the sensor
// 1230 	DLL.calc_level = (unsigned int)(g_slope * (double)DLL.day_level);
        LDI     R26, LOW(DLL)
        LDI     R27, (DLL) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+6
        LDD     R17, Z+7
        LDI     R18, 0
        LDI     R19, 0
        CALL    ?UL2F_L04
        MOVW    R21:R20, R17:R16
        MOVW    R23:R22, R19:R18
        LDI     R30, LOW(g_slope)
        LDI     R31, (g_slope) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        CALL    ?F_MUL_L04
        CALL    ?F2SL_L04
        MOVW    R31:R30, R27:R26
        STD     Z+18, R16
        STD     Z+19, R17
// 1231 #endif
// 1232 }
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock23
// 1233 

        RSEG CODE:CODE:NOROOT(1)
// 1234 void Function_KO165(void)
Function_KO165:
        CFI Block cfiBlock24 Using cfiCommon0
        CFI Function Function_KO165
// 1235 {
// 1236   	occupancy_detect();
        FUNCALL Function_KO165, occupancy_detect
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO165, frame_presence
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO165, Start_Time_Delay
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO165, frame_presence
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        RCALL   occupancy_detect
// 1237 		
// 1238 		if(flags.motion_detected && flags.timer_started == 0)
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        SBRS    R16, 1
        RJMP    ??Function_KO165_0
        LDD     R16, Z+8
        LDD     R17, Z+9
        SBRC    R16, 2
        RJMP    ??Function_KO165_0
// 1239 		{
// 1240 			flags.motion_detected = 0;
        LDD     R16, Z+8
        LDD     R17, Z+9
        ANDI    R16, 0xFD
        STD     Z+9, R17
        STD     Z+8, R16
// 1241 			frame_presence('0');
        LDI     R16, 48
        CALL    frame_presence
// 1242 			Start_Time_Delay();
        CALL    Start_Time_Delay
// 1243 			flags.timer_started = 1;
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+8
        LDD     R17, Z+9
        ORI     R16, 0x04
        STD     Z+9, R17
        STD     Z+8, R16
// 1244 		}
// 1245 		
// 1246 		if(Time_delay.timer_delay_set.time_out)
??Function_KO165_0:
        LDS     R16, (Time_delay + 34)
        TST     R16
        BREQ    ??Function_KO165_1
// 1247 		{
// 1248 			if(flags.motion_detected)
        LDD     R16, Z+8
        LDD     R17, Z+9
        SBRS    R16, 1
        RJMP    ??Function_KO165_1
// 1249 			{
// 1250 				frame_presence('0');
        LDI     R16, 48
        CALL    frame_presence
// 1251 			}
// 1252 		}
// 1253 }
??Function_KO165_1:
        RET
        CFI EndBlock cfiBlock24
// 1254 //******************************************************************************
// 1255 // function for KO168
// 1256 //******************************************************************************

        RSEG CODE:CODE:NOROOT(1)
// 1257 void Function_KO168(char addrestype, char FuncMod, char LightReg)
Function_KO168:
        CFI Block cfiBlock25 Using cfiCommon0
        CFI Function Function_KO168
// 1258 {
// 1259   	daylight_service();
        FUNCALL Function_KO168, daylight_service
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO168, occupancy_detect
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO168, Function_LM_GR
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL Function_KO168, Light_regulation
        LOCFRAME CSTACK, 0, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        CALL    daylight_service
// 1260   	occupancy_detect();
        RCALL   occupancy_detect
// 1261 		Function_LM_GR();	// Function_LM_GR(168);		
        RCALL   Function_LM_GR
// 1262 		Light_regulation();
        CALL    Light_regulation
// 1263 }
        RET
        CFI EndBlock cfiBlock25
// 1264 //******************************************************************************
// 1265 // function mode for LM group end
// 1266 //******************************************************************************
// 1267 
// 1268 
// 1269 

        RSEG CODE:CODE:NOROOT(1)
// 1270 void function_service_init(void)
function_service_init:
        CFI Block cfiBlock26 Using cfiCommon0
        CFI Function function_service_init
// 1271 {
        FUNCALL function_service_init, timer0_enable
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service_init, ultWarmUpEvents
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service_init, daylight_set_init
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service_init, Start_Time_Delay
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service_init, timer_interval_initial
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service_init, timer_5m_initial
        LOCFRAME CSTACK, 8, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        CALL    ?PROLOGUE8_L09
        CFI R7 Frame(CFA_Y, -1)
        CFI R6 Frame(CFA_Y, -2)
        CFI R5 Frame(CFA_Y, -3)
        CFI R4 Frame(CFA_Y, -4)
        CFI R27 Frame(CFA_Y, -5)
        CFI R26 Frame(CFA_Y, -6)
        CFI R25 Frame(CFA_Y, -7)
        CFI R24 Frame(CFA_Y, -8)
        CFI CFA_Y Y+8
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
// 1272 		timer0_enable();                      			// enable timer for sensor detection add 20090408 by alan
        CALL    timer0_enable
// 1273 		ultWarmUpEvents();                    			// init the US detector
        CALL    ultWarmUpEvents
// 1274 		daylight_set_init();
        CALL    daylight_set_init
// 1275 		Sensor_mode.detect_scheme = KO_conf.InitOccu;
        LDI     R26, LOW(KO_conf)
        LDI     R27, (KO_conf) >> 8
        LDS     R16, (KO_conf + 30)
        STS     (Sensor_mode + 2), R16
// 1276 		Time_delay.motion.count = 0;
        LDI     R17, 0
        LDI     R18, 0
        LDI     R19, 0
        LDI     R30, LOW((Time_delay + 61))
        LDI     R31, HIGH((Time_delay + 61))
        ST      Z, R17
        STD     Z+1, R17
        STD     Z+2, R17
        STD     Z+3, R17
// 1277 		Time_delay.motion.time_out = 0;
        STS     (Time_delay + 69), R17
// 1278 		Time_delay.motion.enabled = 1;
        LDI     R16, 1
        STS     (Time_delay + 70), R16
// 1279 		Time_delay.motion.started = 1;
        STS     (Time_delay + 71), R16
// 1280 		Delay_Time_set =  KO_conf.Seconds + (unsigned long int)KO_conf.Minutes*60 + (unsigned long int) KO_conf.Hours*3600;		//calculate the time set by user
        LDS     R4, (KO_conf + 12)
        CLR     R5
        CLR     R6
        CLR     R7
        LDS     R16, (KO_conf + 11)
        LDI     R20, 60
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        CALL    ?L_EC_MUL_L03
        ADD     R4, R16
        ADC     R5, R17
        ADC     R6, R18
        ADC     R7, R19
        LDS     R16, (KO_conf + 10)
        LDI     R17, 0
        LDI     R18, 0
        LDI     R19, 0
        LDI     R20, 16
        LDI     R21, 14
        CALL    ?L_EC_MUL_L03
        ADD     R4, R16
        ADC     R5, R17
        ADC     R6, R18
        ADC     R7, R19
        LDI     R30, LOW(Delay_Time_set)
        LDI     R31, (Delay_Time_set) >> 8
        ST      Z, R4
        STD     Z+1, R5
        STD     Z+2, R6
        STD     Z+3, R7
// 1281 	
// 1282   	set_point = KO_conf.DaylightSetp*5;   	
        LDS     R20, (KO_conf + 25)
        LDI     R21, 0
        LDI     R16, 5
        LDI     R17, 0
        CALL    ?S_EC_MUL_L02
        STS     set_point, R16
        STS     (set_point + 1), R17
// 1283 		if(set_point == 0)	
        LDS     R16, set_point
        LDS     R17, (set_point + 1)
        OR      R16, R17
        BRNE    ??function_service_init_0
// 1284 			set_point = 1500;		// for debug alan
        LDI     R16, 220
        LDI     R17, 5
        STS     set_point, R16
        STS     (set_point + 1), R17
// 1285 	
// 1286 		if(KO_conf.KO_number == 128)
??function_service_init_0:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+47
        LDD     R17, Z+48
        CPI     R16, 128
        CPC     R17, R22
        BRNE    ??function_service_init_1
// 1287     {
// 1288      		M2_timer = (eep_M2_hour*3600 + eep_M2_min*60 + eep_M2_sec);			
        LDI     R20, LOW(eep_M2_hour)
        LDI     R21, (eep_M2_hour) >> 8
        CALL    __eeget8_16
        MOV     R20, R16
        LDI     R21, 0
        LDI     R16, 16
        LDI     R17, 14
        CALL    ?S_EC_MUL_L02
        MOVW    R25:R24, R17:R16
        LDI     R20, LOW(eep_M2_min)
        LDI     R21, (eep_M2_min) >> 8
        CALL    __eeget8_16
        MOV     R20, R16
        LDI     R21, 0
        LDI     R16, 60
        LDI     R17, 0
        CALL    ?S_EC_MUL_L02
        ADD     R24, R16
        ADC     R25, R17
        LDI     R20, LOW(eep_M2_sec)
        LDI     R21, (eep_M2_sec) >> 8
        CALL    __eeget8_16
        ADD     R24, R16
        ADC     R25, R22
        MOVW    R17:R16, R25:R24
        MOV     R18, R17
        LSL     R18
        SBC     R18, R18
        LDI     R30, LOW(M2_timer)
        LDI     R31, (M2_timer) >> 8
        ST      Z, R24
        STD     Z+1, R25
        STD     Z+2, R18
        STD     Z+3, R18
// 1289 				Start_Time_Delay();											//call Start_Time_Delay() to send the dll frame every 5min
        CALL    Start_Time_Delay
// 1290       	if(M2_timer == 0)		M2_timer = 5;   		// for debug //default presence frame interval time
        LDI     R30, LOW(M2_timer)
        LDI     R31, (M2_timer) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        OR      R16, R17
        OR      R16, R18
        OR      R16, R19
        BRNE    ??function_service_init_1
        LDI     R16, 5
        LDI     R17, 0
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R17
        STD     Z+3, R17
// 1291     }
// 1292 		
// 1293 		
// 1294 		 switch(KO_conf.KO_number)
??function_service_init_1:
        ADIW    R27:R26, 47
        LD      R30, X+
        LD      R31, X
        SUBI    R30, 119
        SBCI    R31, 0
        BREQ    ??function_service_init_2
        SBIW    R31:R30, 9
        BREQ    ??function_service_init_3
        SBIW    R31:R30, 40
        BRNE    ??function_service_init_4
// 1295 		{
// 1296 			case 119:
// 1297 			case 168:
// 1298 				// sensitivity of the sensor is set in the files PIR.c and US.c
// 1299 				Sensor_mode.mode_state = 1;	
??function_service_init_2:
        LDI     R16, 1
        STS     Sensor_mode, R16
// 1300 				if(KO_conf.FuncMod == ManualON_Auto_OFF)	
        LDS     R16, (KO_conf + 29)
        CPI     R16, 3
        BRNE    ??function_service_init_5
// 1301 					Sensor_mode.manual_on_need = 1;     // in manualon mode
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+5
        ORI     R16, 0x40
        STD     Z+5, R16
// 1302 				if (KO_conf.LightReg)
??function_service_init_5:
        LDS     R16, (KO_conf + 28)
        TST     R16
        BREQ    ??function_service_init_4
// 1303 					Sensor_mode.flag_leader_group = 1;
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+5
        ORI     R16, 0x02
        STD     Z+5, R16
        RJMP    ??function_service_init_4
// 1304 			break;
// 1305 			
// 1306 			case 128:
// 1307 				timer_interval_initial(1000);
??function_service_init_3:
        LDI     R16, 232
        LDI     R17, 3
        LDI     R18, 0
        LDI     R19, 0
        RCALL   timer_interval_initial
// 1308 				timer_5m_initial(MIN_5);
        LDI     R16, 224
        LDI     R17, 147
        LDI     R18, 4
        LDI     R19, 0
        RCALL   timer_5m_initial
// 1309 				DLL.daylight_SampleCount = 0;
        LDI     R16, 0
        STS     (DLL + 1), R16
// 1310 				flags.KO_128_first_sampel_ready = 0;
        LDI     R30, LOW(flags)
        LDI     R31, (flags) >> 8
        LDD     R16, Z+12
        LDD     R17, Z+13
        ANDI    R16, 0xEF
        STD     Z+13, R17
        STD     Z+12, R16
// 1311 			break;
// 1312 			
// 1313 			case 165:
// 1314 			break;
// 1315 			
// 1316 			default:break;	
// 1317 		}
// 1318 	/*
// 1319 		KO_conf.KO_number = 168;	//debug
// 1320 		KO_conf.en_load = 1;
// 1321 		KO_conf.GR = 2;	
// 1322 		KO_conf.Reference = 2;
// 1323 		KO_conf.AddressType = 2;
// 1324 		Delay_Time_set =  30;
// 1325 		KO_conf.FuncMod = ManualON_Auto_OFF;
// 1326 	*/
// 1327 
// 1328 }
??function_service_init_4:
        LDI     R30, 8
        JMP     ?EPILOGUE_B8_L09
        CFI EndBlock cfiBlock26
// 1329 
// 1330 //#pragma optimize=none

        RSEG CODE:CODE:NOROOT(1)
// 1331 void function_service(void)
function_service:
        CFI Block cfiBlock27 Using cfiCommon0
        CFI Function function_service
// 1332 {
        FUNCALL function_service, StrToChar
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, StrToChar
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, function_service_init
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, Function_KO119
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, Function_KO128
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, Function_KO165
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, Function_KO166
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        FUNCALL function_service, Function_KO168
        LOCFRAME CSTACK, 2, STACK
        LOCFRAME RSTACK, 2, STACK
        ARGFRAME RSTACK, 0, STACK
        ST      -Y, R27
        CFI R27 Frame(CFA_Y, -1)
        CFI CFA_Y Y+1
        ST      -Y, R26
        CFI R26 Frame(CFA_Y, -2)
        CFI CFA_Y Y+2
// 1333 
// 1334   if(Sensor_mode.init_OK == 0)			// if not initialed
        LDI     R26, LOW(KO_conf)
        LDI     R27, (KO_conf) >> 8
        LDI     R30, LOW(Sensor_mode)
        LDI     R31, (Sensor_mode) >> 8
        LDD     R16, Z+7
        SBRC    R16, 7
        RJMP    ??function_service_0
// 1335 	{
// 1336 			Sensor_mode.init_OK = 1;
        LDD     R16, Z+7
        ORI     R16, 0x80
        STD     Z+7, R16
// 1337 			KO_conf.KO_number = StrToChar(KO);				
        LDI     R16, LOW(KO)
        LDI     R17, (KO) >> 8
        CALL    StrToChar
        LDI     R17, 0
        MOVW    R31:R30, R27:R26
        STD     Z+47, R16
        STD     Z+48, R17
// 1338 			KO_conf.KO_number = KO_conf.KO_number<<8;
        LDD     R16, Z+47
        LDD     R17, Z+48
        MOV     R17, R16
        LDI     R16, 0
        STD     Z+47, R16
        STD     Z+48, R17
// 1339 			KO_conf.KO_number += StrToChar(&KO[2]);
        LDI     R16, LOW((KO + 2))
        LDI     R17, HIGH((KO + 2))
        CALL    StrToChar
        LDI     R17, 0
        MOVW    R31:R30, R27:R26
        LDD     R18, Z+47
        LDD     R19, Z+48
        ADD     R18, R16
        ADC     R19, R17
        STD     Z+47, R18
        STD     Z+48, R19
// 1340 	  	function_service_init();
        RCALL   function_service_init
// 1341 			SCS_received.P2P_actuator_flag = 1;
        LDI     R30, LOW(SCS_received)
        LDI     R31, (SCS_received) >> 8
        LDD     R16, Z+2
        ORI     R16, 0x01
        STD     Z+2, R16
// 1342 			SCS_received.P2P_dimmer_flag = 0;
        LDD     R16, Z+2
        ANDI    R16, 0xFD
        STD     Z+2, R16
// 1343 	}
// 1344 
// 1345 	//set_point = KO_conf.DaylightSetp*5;
// 1346 	
// 1347   switch(KO_conf.KO_number)
??function_service_0:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+47
        LDD     R17, Z+48
        LDI     R30, LOW(`?<Jumptable for function_service>_0`)
        LDI     R31, (`?<Jumptable for function_service>_0`) >> 8
        JMP     ?SV_SWITCH_L06
// 1348 	{
// 1349 		case 112:
// 1350 		
// 1351 		  	break;
// 1352 		case 119:
// 1353 		  	Function_KO119();
??function_service_1:
        RCALL   Function_KO119
        RJMP    ??function_service_2
// 1354 		 	break;
// 1355 		case 128:
// 1356 		  	Function_KO128();  				//_modality_2();
??function_service_3:
        RCALL   Function_KO128
        RJMP    ??function_service_2
// 1357 		  	break;
// 1358 		case 164:
// 1359 		
// 1360 		  	break;
// 1361 		case 165:
// 1362 		  	Function_KO165();
??function_service_4:
        RCALL   Function_KO165
        RJMP    ??function_service_2
// 1363 		  	break;
// 1364 		case 166:
// 1365 		  	// Function_KO166(2,x,x); 		// Group
// 1366 		  	// Function_KO166(0,1,0);  		//_modality_1();
// 1367 		  	// Function_KO166(0,3,1);  		//_modality_4();
// 1368 		  	// void Function_KO166(char addrestype, char detectype, char LightReg);
// 1369 				Function_KO166(KO_conf.AddressType, KO_conf.FuncMod, KO_conf.LightReg);
??function_service_5:
        LDS     R18, (KO_conf + 28)
        LDS     R17, (KO_conf + 29)
        LDS     R16, (KO_conf + 1)
        RCALL   Function_KO166
        RJMP    ??function_service_2
// 1370 		  	break;
// 1371 		case 168:
// 1372 		  	// Function_KO168(2,x,x);  		// Group
// 1373 		  	// Function_KO168(0,1,0);  		//_modality_0();	
// 1374 		  	// Function_KO168(0,1,1);  		//_modality_3();	
// 1375 		  	// void Function_KO168(char addrestype, char FuncMod, char LightReg);
// 1376 		  	Function_KO168(KO_conf.AddressType, KO_conf.FuncMod, KO_conf.LightReg); 	
??function_service_6:
        LDS     R18, (KO_conf + 28)
        LDS     R17, (KO_conf + 29)
        LDS     R16, (KO_conf + 1)
        RCALL   Function_KO168
// 1377 				//Function_KO168(2,1,1);
// 1378 		  	break;
// 1379 		case 0x203:
// 1380 			/*
// 1381 		  if(Configurators.M == '0')		
// 1382 				Function_KO168(0,1,0);  	//_modality_0();	
// 1383 			else if(Configurators.M == '2')	
// 1384 				Function_KO128(); 			//_modality_2();
// 1385 			else if(Configurators.M == '3')	    Function_KO168(0,1,1);  	//_modality_3();	
// 1386 			*/
// 1387 		  	break;
// 1388 		case 0x204:
// 1389 		  /*
// 1390 		  if(Configurators.M == '1')			
// 1391 				Function_KO166(0,1,0);  									//_modality_1();
// 1392 			else if(Configurators.M == '4')		Function_KO166(0,3,1);  	//_modality_4();
// 1393 		  */
// 1394 		  	break;
// 1395 		case 0x1FF:
// 1396 		
// 1397 		  	break;
// 1398 		default:
// 1399 		  	break;	
// 1400 	}
// 1401 }
??function_service_2:
        LD      R26, Y+
        CFI R26 SameValue
        CFI CFA_Y Y+1
        LD      R27, Y+
        CFI R27 SameValue
        CFI CFA_Y Y+0
        RET
        CFI EndBlock cfiBlock27
// 1402 

        RSEG CODE:CODE:NOROOT(1)
// 1403 void check_frame_received_maintain(void)
check_frame_received_maintain:
        CFI Block cfiBlock28 Using cfiCommon0
        CFI Function check_frame_received_maintain
// 1404 {
// 1405 	
// 1406 }
        RET
        CFI EndBlock cfiBlock28
// 1407 

        RSEG CODE:CODE:NOROOT(1)
// 1408 void timer_interval_initial(unsigned long int ms)
timer_interval_initial:
        CFI Block cfiBlock29 Using cfiCommon0
        CFI Function timer_interval_initial
// 1409 {
// 1410 	Time_delay.sample_interval.stack_top = ms;
        LDI     R30, LOW((Time_delay + 307))
        LDI     R31, HIGH((Time_delay + 307))
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
// 1411 	Time_delay.sample_interval.count = 0;
        LDI     R16, 0
        LDI     R30, LOW((Time_delay + 303))
        LDI     R31, HIGH((Time_delay + 303))
        ST      Z, R16
        STD     Z+1, R16
        STD     Z+2, R16
        STD     Z+3, R16
// 1412 	Time_delay.sample_interval.time_out = 0;
        STS     (Time_delay + 311), R16
// 1413 	Time_delay.sample_interval.enabled = 1;
        LDI     R16, 1
        STS     (Time_delay + 312), R16
// 1414 	Time_delay.sample_interval.started = 1;
        STS     (Time_delay + 313), R16
// 1415 }
        RET
        CFI EndBlock cfiBlock29
// 1416 

        RSEG CODE:CODE:NOROOT(1)
// 1417 void timer_5m_initial(unsigned long int ms)
timer_5m_initial:
        CFI Block cfiBlock30 Using cfiCommon0
        CFI Function timer_5m_initial
// 1418 {
// 1419 	Time_delay.timer_5m.stack_top = ms;
        LDI     R30, LOW((Time_delay + 76))
        LDI     R31, HIGH((Time_delay + 76))
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
// 1420 	Time_delay.timer_5m.count = 0;
        LDI     R16, 0
        LDI     R30, LOW((Time_delay + 72))
        LDI     R31, HIGH((Time_delay + 72))
        ST      Z, R16
        STD     Z+1, R16
        STD     Z+2, R16
        STD     Z+3, R16
// 1421 	Time_delay.timer_5m.time_out = 0;
        STS     (Time_delay + 80), R16
// 1422 	Time_delay.timer_5m.enabled = 1;
        LDI     R16, 1
        STS     (Time_delay + 81), R16
// 1423 	Time_delay.timer_5m.started = 1;
        STS     (Time_delay + 82), R16
// 1424 }
        RET
        CFI EndBlock cfiBlock30

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,022H
__?EEARH:

        RSEG SWITCH:CODE:NOROOT(1)
`?<Jumptable for function_service>_0`:
        DW      30464
        DB      1
        DW      (??function_service_2) /2
        DW      (??function_service_1) /2
        DB      0x9
        DW      (??function_service_3) /2
        DB      0x25
        DW      (??function_service_4) /2
        DB      0x1
        DW      (??function_service_5) /2
        DB      0x2
        DW      (??function_service_6) /2
        DB      251

        END
// 
// 5 300 bytes in segment CODE
//    20 bytes in segment SWITCH
// 
// 5 320 bytes of CODE memory
//
//Errors: none
//Warnings: none
