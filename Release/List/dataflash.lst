###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.30.0.50166/W32 for Atmel AVR    11/Dec/2009  23:21:01 #
# Copyright 1996-2009 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\avr\LM_Finial_Test\dataflash.c                        #
#    Command line =  D:\avr\LM_Finial_Test\dataflash.c --cpu=m644p -ms -o     #
#                    D:\avr\LM_Finial_Test\Release\Obj\ -D NDEBUG -D LM018    #
#                    -D FINAL_VERSION2 -lCN D:\avr\LM_Finial_Test\Release\Lis #
#                    t\ -lA D:\avr\LM_Finial_Test\Release\List\               #
#                    --diag_suppress Pa082,Pe167,Pe186                        #
#                    --initializers_in_flash -z6 --no_inline --no_cross_call  #
#                    --no_tbaa -DENABLE_BIT_DEFINITIONS -e -I "C:\Program     #
#                    Files\IAR Systems\Embedded Workbench 5.3\avr\INC\" -I    #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.3\avr\INC\CLIB\" --eeprom_size 2048                    #
#    List file    =  D:\avr\LM_Finial_Test\Release\List\dataflash.lst         #
#    Object file  =  D:\avr\LM_Finial_Test\Release\Obj\dataflash.r90          #
#                                                                             #
#                                                                             #
###############################################################################

D:\avr\LM_Finial_Test\dataflash.c
      1          /*
      2          	Last change:  RM   17 Jan 2001   20:15
      3          */
      4          
      5          //*****************************************************************************
      6          //
      7          //      COPYRIGHT (c) ATMEL Norway, 1996-2001
      8          //
      9          //      The copyright to the document(s) herein is the property of
     10          //      ATMEL Norway, Norway.
     11          //
     12          //      The document(s) may be used  and/or copied only with the written
     13          //      permission from ATMEL Norway or in accordance with the terms and
     14          //      conditions stipulated in the agreement/contract under which the
     15          //      document(s) have been supplied.
     16          //
     17          //*****************************************************************************
     18          //
     19          //  File........: DATAFLASH.C
     20          //
     21          //  Author(s)...: ATMEL Norway
     22          //
     23          //  Target(s)...: All AVRs with built-in HW SPI
     24          //
     25          //  Description.: Functions to access the Atmel AT45Dxxx dataflash series
     26          //				  Supports 512Kbit - 64Mbit
     27          //
     28          //  Revisions...:
     29          //
     30          //  YYYYMMDD - VER. - COMMENT                                       - SIGN.
     31          //
     32          //  20011017 - 1.00 - Beta release                                  -  RM
     33          //  20011017 - 0.10 - Generated file                                -  RM
     34          //
     35          //*****************************************************************************
     36          
     37          // Includes
     38          //#include <INA90.H>
     39          //#include "iom169.h"
     40          #include <ioavr.h>

   \                                 In  segment ABSOLUTE, at 0x4e
   \   <__C171> volatile __io _A_SPDR
   \                     _A_SPDR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4d
   \   <__C174> volatile __io _A_SPSR
   \                     _A_SPSR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x4c
   \   <__C177> volatile __io _A_SPCR
   \                     _A_SPCR:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x28
   \   <__C237> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x27
   \   <__C240> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x25
   \   <__C246> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x24
   \   <__C249> volatile __io _A_DDRB
   \                     _A_DDRB:
   \   00000000                      DS8 1
     41          #include <inavr.h>
     42          #include "dataflash.h"
     43          #include "global_variable.h"
     44          #include "board.h"
     45          
     46          // Constants
     47          //Look-up table for these sizes ->  512k, 1M, 2M, 4M, 8M, 16M, 32M, 64M

   \                                 In  segment NEAR_F, align 1, keep-with-next
     48          __flash unsigned char DF_pagebits[]  ={  9,  9,  9,  9,  9,  10,  10,  11};	    //index of internal page address bits
     49          //Look-up table for these sizes ->  512k, 1M,  2M,  4M,  8M, 16M, 32M, 64M
     50          __flash unsigned int  DF_pagesize[]  ={264,264, 264, 264, 264, 528, 528,1056};	//index of pagesizes
   \                     DF_pagesize:
   \   00000000   010801080108       DC16 264, 264, 264, 264, 264, 528, 528, 1056
   \              010801080210
   \              02100420    
   \                     DF_pagebits:
   \   00000010   090909090A09       DC8 9, 9, 9, 9, 9, 10, 10, 11
   \              0B0A        
     51          
     52          
     53          // Globals

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     54          unsigned char PageBits;
     55          unsigned int  PageSize;
   \                     PageSize:
   \   00000000                      DS8 2
   \                     PageBits:
   \   00000002                      DS8 1
     56          // Functions
     57          
     58          /*****************************************************************************
     59          *
     60          *	Function name : DF_SPI_init
     61          *
     62          *	Returns :		None
     63          *
     64          *	Parameters :	None
     65          *
     66          *	Purpose :		Sets up the HW SPI in Master mode, Mode 3
     67          *					Note -> Uses the SS line to control the DF CS-line.
     68          *
     69          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
     70          void DF_SPI_init (void)
   \                     DF_SPI_init:
     71          {
     72          	PORTB |= (1<<PORTB5) | (1<<PORTB7);
   \   00000000   B105               IN      R16, 0x05
   \   00000002   6A00               ORI     R16, 0xA0
   \   00000004   B905               OUT     0x05, R16
     73          	DDRB |= (1<<PORTB5) | (1<<PORTB7);		//Set MOSI, SCK AND SS as outputs
   \   00000006   B104               IN      R16, 0x04
   \   00000008   6A00               ORI     R16, 0xA0
   \   0000000A   B904               OUT     0x04, R16
     74          	
     75          	SetBit(DDRC,0);			//dataflash cs
   \   0000000C   9A38               SBI     0x07, 0x00
     76          	ClrBit(PORTC,0);
   \   0000000E   9840               CBI     0x08, 0x00
     77          	
     78          	ClrBit(DDRC,1);			//dataflash reset
   \   00000010   9839               CBI     0x07, 0x01
     79          	SetBit(PORTC,1);
   \   00000012   9A41               SBI     0x08, 0x01
     80          	
     81          	SPSR = (1<<SPI2X0);                                      //SPI double speed settings
   \   00000014   E001               LDI     R16, 1
   \   00000016   BD0D               OUT     0x2D, R16
     82          	SPCR = (1<<SPE0) | (1<<MSTR0) | (1<<CPHA0) | (1<<CPOL0);	//Enable SPI in Master mode, mode 3, Fosc/2
   \   00000018   E50C               LDI     R16, 92
   \   0000001A   BD0C               OUT     0x2C, R16
     83          //	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA) | (1<<CPOL) | (1<<SPR1) | (1<<SPR0);	//Enable SPI in Master mode, mode 3, Fosc/2
     84          }
   \   0000001C   9508               RET
   \   0000001E                      REQUIRE _A_SPSR
   \   0000001E                      REQUIRE _A_SPCR
   \   0000001E                      REQUIRE _A_PORTC
   \   0000001E                      REQUIRE _A_DDRC
   \   0000001E                      REQUIRE _A_PORTB
   \   0000001E                      REQUIRE _A_DDRB
     85          

   \                                 In  segment CODE, align 2, keep-with-next
     86          void DF_SPI_disable(void)
   \                     DF_SPI_disable:
     87          {
     88          	ClrBit(SPCR,SPE0);
   \   00000000   B50C               IN      R16, 0x2C
   \   00000002   7B0F               ANDI    R16, 0xBF
   \   00000004   BD0C               OUT     0x2C, R16
     89          }
   \   00000006   9508               RET
   \   00000008                      REQUIRE _A_SPCR
     90          /*****************************************************************************
     91          *
     92          *	Function name : DF_SPI_RW
     93          *
     94          *	Returns :		Byte read from SPI data register (any value)
     95          *
     96          *	Parameters :	Byte to be written to SPI data register (any value)
     97          *
     98          *	Purpose :		Read and writes one byte from/to SPI master
     99          *
    100          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    101          unsigned char DF_SPI_RW (unsigned char output)
   \                     DF_SPI_RW:
    102          {
    103          	unsigned char input;
    104          	
    105          	SPDR = output;							//put byte 'output' in SPI data register
   \   00000000   BD0E               OUT     0x2E, R16
    106          	while(!(SPSR & 0x80));					//wait for transfer complete, poll SPIF-flag
   \                     ??DF_SPI_RW_0:
   \   00000002   B50D               IN      R16, 0x2D
   \   00000004   2F10               MOV     R17, R16
   \   00000006   FF17               SBRS    R17, 7
   \   00000008   CFFC               RJMP    ??DF_SPI_RW_0
    107          	input = SPDR;							//read value in SPI data reg.
   \   0000000A   B50E               IN      R16, 0x2E
    108          	
    109          	return input;							//return the byte clocked in from SPI slave
   \   0000000C   9508               RET
   \   0000000E                      REQUIRE _A_SPDR
   \   0000000E                      REQUIRE _A_SPSR
    110          }		
    111          
    112          
    113          /*****************************************************************************
    114          *
    115          *	Function name : Read_DF_status
    116          *
    117          *	Returns :		One status byte. Consult Dataflash datasheet for further
    118          *					decoding info
    119          *
    120          *	Parameters :	None
    121          *
    122          *	Purpose :		Status info concerning the Dataflash is busy or not.
    123          *					Status info concerning compare between buffer and flash page
    124          *					Status info concerning size of actual device
    125          *
    126          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    127          unsigned char Read_DF_status (void)
   \                     Read_DF_status:
    128          {
    129          	unsigned char result,index_copy;
    130          	
    131          	DF_CS_inactive;							//make sure to toggle CS signal in order
   \   00000000   9A40               SBI     0x08, 0x00
    132          	DF_CS_active;							//to reset dataflash command decoder
   \   00000002   9840               CBI     0x08, 0x00
    133          	result = DF_SPI_RW(StatusReg);			//send status register read op-code
   \   00000004   E507               LDI     R16, 87
   \   00000006   ....               RCALL   DF_SPI_RW
    134          	result = DF_SPI_RW(0x00);				//dummy write to get result
   \   00000008   E000               LDI     R16, 0
   \   0000000A   ....               RCALL   DF_SPI_RW
    135          	
    136          	index_copy = ((result & 0x38) >> 3);	//get the size info from status register
   \   0000000C   2F20               MOV     R18, R16
   \   0000000E   7328               ANDI    R18, 0x38
   \   00000010   9526               LSR     R18
   \   00000012   9526               LSR     R18
   \   00000014   9526               LSR     R18
   \   00000016   E030               LDI     R19, 0
   \   00000018   01F9               MOVW    R31:R30, R19:R18
   \   0000001A   ....               SUBI    R30, LOW((-(DF_pagesize + 16) & 0xFFFF))
   \   0000001C   ....               SBCI    R31, HIGH((-(DF_pagesize + 16) & 0xFFFF))
   \   0000001E   9114               LPM     R17, Z
   \   00000020   9310....           STS     (PageSize + 2), R17
    137          	PageBits   = DF_pagebits[index_copy];	//get number of internal page address bits from look-up table
    138          	PageSize   = DF_pagesize[index_copy];   //get the size of the page (in bytes)
   \   00000024   E012               LDI     R17, 2
   \   00000026   9F21               MUL     R18, R17
   \   00000028   01F0               MOVW    R31:R30, R1:R0
   \   0000002A   ....               SUBI    R30, LOW((-(DF_pagesize) & 0xFFFF))
   \   0000002C   ....               SBCI    R31, (-(DF_pagesize) & 0xFFFF) >> 8
   \   0000002E   9125               LPM     R18, Z+
   \   00000030   9134               LPM     R19, Z
   \   00000032   9320....           STS     PageSize, R18
   \   00000036   9330....           STS     (PageSize + 1), R19
    139          	return result;							//return the read status register value
   \   0000003A   9508               RET
   \   0000003C                      REQUIRE _A_PORTC
    140          }
    141          
    142          
    143          /*****************************************************************************
    144          *
    145          *	Function name : Page_To_Buffer
    146          *
    147          *	Returns :		None
    148          *
    149          *	Parameters :	BufferNo	->	Decides usage of either buffer 1 or 2
    150          *					PageAdr		->	Address of page to be transferred to buffer
    151          *
    152          *	Purpose :		Transfers a page from flash to dataflash SRAM buffer
    153          *					
    154          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    155          void Page_To_Buffer (unsigned int PageAdr, unsigned char BufferNo)
   \                     Page_To_Buffer:
    156          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
    157          	DF_CS_inactive;												//make sure to toggle CS signal in order
   \   00000006   9A40               SBI     0x08, 0x00
    158          	DF_CS_active;												//to reset dataflash command decoder
   \   00000008   9840               CBI     0x08, 0x00
    159          	
    160          	if (1 == BufferNo)											//transfer flash page to buffer 1
   \   0000000A   3021               CPI     R18, 1
   \   0000000C   F491               BRNE    ??Page_To_Buffer_0
    161          	{
    162          		DF_SPI_RW(FlashToBuf1Transfer);							//transfer to buffer 1 op-code
   \   0000000E   E503               LDI     R16, 83
   \   00000010   ....               RCALL   DF_SPI_RW
    163          		DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));	//upper part of page address
   \   00000012   9180....           LDS     R24, (PageSize + 2)
   \   00000016   E140               LDI     R20, 16
   \   00000018   1B48               SUB     R20, R24
   \   0000001A   018D               MOVW    R17:R16, R27:R26
   \   0000001C   ........           CALL    ?US_SHR_L02
   \   00000020   ....               RCALL   DF_SPI_RW
    164          		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
   \   00000022   5088               SUBI    R24, 8
   \   00000024   2F48               MOV     R20, R24
   \   00000026   018D               MOVW    R17:R16, R27:R26
   \   00000028   ........           CALL    ?S_SHL_L02
   \   0000002C   ....               RCALL   DF_SPI_RW
    165          		DF_SPI_RW(0x00);										//don't cares
   \   0000002E   E000               LDI     R16, 0
   \   00000030   ....               RCALL   DF_SPI_RW
    166          	}
    167          #ifdef USE_BUFFER2
    168          	else	
    169          	if (2 == BufferNo)											//transfer flash page to buffer 2
    170          	{
    171          		DF_SPI_RW(FlashToBuf2Transfer);							//transfer to buffer 2 op-code
    172          		DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));	//upper part of page address
    173          		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
    174          		DF_SPI_RW(0x00);										//don't cares
    175          	}
    176          #endif
    177          	
    178          	DF_CS_inactive;												//initiate the transfer
   \                     ??Page_To_Buffer_0:
   \   00000032   9A40               SBI     0x08, 0x00
    179          	DF_CS_active;
   \   00000034   9840               CBI     0x08, 0x00
    180          	
    181          	while(!(Read_DF_status() & 0x80));							//monitor the status register, wait until busy-flag is high
   \                     ??Page_To_Buffer_1:
   \   00000036   ....               RCALL   Read_DF_status
   \   00000038   FB07               BST     R16, 7
   \   0000003A   F7EE               BRTC    ??Page_To_Buffer_1
    182          }
   \   0000003C   E0E4               LDI     R30, 4
   \   0000003E   ........           JMP     ?EPILOGUE_B4_L09
   \   00000042                      REQUIRE _A_PORTC
    183          
    184          
    185          
    186          /*****************************************************************************
    187          *
    188          *	Function name : Buffer_Read_Byte
    189          *
    190          *	Returns :		One read byte (any value)
    191          *
    192          *	Parameters :	BufferNo	->	Decides usage of either buffer 1 or 2
    193          *					IntPageAdr	->	Internal page address
    194          *
    195          *	Purpose :		Reads one byte from one of the dataflash
    196          *					internal SRAM buffers
    197          *
    198          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    199          unsigned char Buffer_Read_Byte (unsigned char BufferNo, unsigned int IntPageAdr)
   \                     Buffer_Read_Byte:
    200          {
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   01C9               MOVW    R25:R24, R19:R18
    201          	unsigned char data;
    202          	
    203          	DF_CS_inactive;								//make sure to toggle CS signal in order
   \   00000006   9A40               SBI     0x08, 0x00
    204          	DF_CS_active;								//to reset dataflash command decoder
   \   00000008   9840               CBI     0x08, 0x00
    205          	
    206          	if (1 == BufferNo)							//read byte from buffer 1
   \   0000000A   3001               CPI     R16, 1
   \   0000000C   F471               BRNE    ??Buffer_Read_Byte_0
    207          	{
    208          		DF_SPI_RW(Buf1Read);					//buffer 1 read op-code
   \   0000000E   E504               LDI     R16, 84
   \   00000010   ....               RCALL   DF_SPI_RW
    209          		DF_SPI_RW(0x00);						//don't cares
   \   00000012   E000               LDI     R16, 0
   \   00000014   ....               RCALL   DF_SPI_RW
    210          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
   \   00000016   018C               MOVW    R17:R16, R25:R24
   \   00000018   2F01               MOV     R16, R17
   \   0000001A   ....               RCALL   DF_SPI_RW
    211          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
   \   0000001C   2F08               MOV     R16, R24
   \   0000001E   ....               RCALL   DF_SPI_RW
    212          		DF_SPI_RW(0x00);						//don't cares
   \   00000020   E000               LDI     R16, 0
   \   00000022   ....               RCALL   DF_SPI_RW
    213          		data = DF_SPI_RW(0x00);					//read byte
   \   00000024   E000               LDI     R16, 0
   \   00000026   ....               RCALL   DF_SPI_RW
   \   00000028   2F10               MOV     R17, R16
    214          	}
    215          
    216          #ifdef USE_BUFFER2
    217          	else
    218          	if (2 == BufferNo)							//read byte from buffer 2
    219          	{
    220          		DF_SPI_RW(Buf2Read);					//buffer 2 read op-code
    221          		DF_SPI_RW(0x00);						//don't cares
    222          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    223          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    224          		DF_SPI_RW(0x00);						//don't cares
    225          		data = DF_SPI_RW(0x00);					//read byte
    226          	}
    227          #endif
    228          	
    229          	return data;								//return the read data byte
   \                     ??Buffer_Read_Byte_0:
   \   0000002A   2F01               MOV     R16, R17
   \   0000002C   9189               LD      R24, Y+
   \   0000002E   9199               LD      R25, Y+
   \   00000030   9508               RET
   \   00000032                      REQUIRE _A_PORTC
    230          }
    231          
    232          
    233          
    234          /*****************************************************************************
    235          *
    236          *	Function name : Buffer_Read_Str
    237          *
    238          *	Returns :		None
    239          *
    240          *	Parameters :	BufferNo	->	Decides usage of either buffer 1 or 2
    241          *					IntPageAdr	->	Internal page address
    242          *					No_of_bytes	->	Number of bytes to be read
    243          *					*BufferPtr	->	address of buffer to be used for read bytes
    244          *
    245          *	Purpose :		Reads one or more bytes from one of the dataflash
    246          *					internal SRAM buffers, and puts read bytes into
    247          *					buffer pointed to by *BufferPtr
    248          *
    249          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    250          void Buffer_Read_Str (unsigned char BufferNo, unsigned int IntPageAdr, unsigned int No_of_bytes, unsigned char *BufferPtr)
   \                     Buffer_Read_Str:
    251          {
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   01D9               MOVW    R27:R26, R19:R18
   \   00000006   012A               MOVW    R5:R4, R21:R20
   \   00000008   01CB               MOVW    R25:R24, R23:R22
    252          	unsigned int i;
    253          
    254          	DF_CS_inactive;								//make sure to toggle CS signal in order
   \   0000000A   9A40               SBI     0x08, 0x00
    255          	DF_CS_active;								//to reset dataflash command decoder
   \   0000000C   9840               CBI     0x08, 0x00
    256          	
    257          	if (1 == BufferNo)							//read byte(s) from buffer 1
   \   0000000E   3001               CPI     R16, 1
   \   00000010   F4B9               BRNE    ??Buffer_Read_Str_0
    258          	{
    259          		DF_SPI_RW(Buf1Read);					//buffer 1 read op-code
   \   00000012   E504               LDI     R16, 84
   \   00000014   ....               RCALL   DF_SPI_RW
    260          		DF_SPI_RW(0x00);						//don't cares
   \   00000016   E000               LDI     R16, 0
   \   00000018   ....               RCALL   DF_SPI_RW
    261          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
   \   0000001A   018D               MOVW    R17:R16, R27:R26
   \   0000001C   2F01               MOV     R16, R17
   \   0000001E   ....               RCALL   DF_SPI_RW
    262          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
   \   00000020   2F0A               MOV     R16, R26
   \   00000022   ....               RCALL   DF_SPI_RW
    263          		DF_SPI_RW(0x00);						//don't cares
   \   00000024   E000               LDI     R16, 0
   \   00000026   ....               RCALL   DF_SPI_RW
    264          		for( i=0; i<No_of_bytes; i++)
   \   00000028   E0A0               LDI     R26, 0
   \   0000002A   E0B0               LDI     R27, 0
   \   0000002C   C006               RJMP    ??Buffer_Read_Str_1
    265          		{
    266          			*(BufferPtr) = DF_SPI_RW(0x00);		//read byte and put it in AVR buffer pointed to by *BufferPtr
   \                     ??Buffer_Read_Str_2:
   \   0000002E   E000               LDI     R16, 0
   \   00000030   ....               RCALL   DF_SPI_RW
   \   00000032   01FC               MOVW    R31:R30, R25:R24
   \   00000034   9301               ST      Z+, R16
   \   00000036   01CF               MOVW    R25:R24, R31:R30
    267          			BufferPtr++;						//point to next element in AVR buffer
    268          		}
   \   00000038   9611               ADIW    R27:R26, 1
   \                     ??Buffer_Read_Str_1:
   \   0000003A   15A4               CP      R26, R4
   \   0000003C   05B5               CPC     R27, R5
   \   0000003E   F3B8               BRCS    ??Buffer_Read_Str_2
    269          	}
    270          	
    271          #ifdef USE_BUFFER2
    272          	else
    273          	if (2 == BufferNo)							//read byte(s) from buffer 2
    274          	{
    275          		DF_SPI_RW(Buf2Read);					//buffer 2 read op-code
    276          		DF_SPI_RW(0x00);						//don't cares
    277          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    278          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    279          		DF_SPI_RW(0x00);						//don't cares
    280          		for( i=0; i<No_of_bytes; i++)
    281          		{
    282          			*(BufferPtr) = DF_SPI_RW(0x00);		//read byte and put it in AVR buffer pointed to by *BufferPtr
    283          			BufferPtr++;						//point to next element in AVR buffer
    284          		}
    285          	}
    286          #endif
    287          }
   \                     ??Buffer_Read_Str_0:
   \   00000040   E0E6               LDI     R30, 6
   \   00000042   ........           JMP     ?EPILOGUE_B6_L09
   \   00000046                      REQUIRE _A_PORTC
    288          //NB : Sjekk at (IntAdr + No_of_bytes) < buffersize, hvis ikke blir det bare ball..
    289          
    290          
    291          
    292          /*****************************************************************************
    293          *
    294          *	Function name : Buffer_Write_Enable
    295          *
    296          *	Returns :		None
    297          *
    298          *	Parameters :	IntPageAdr	->	Internal page address to start writing from
    299          *					BufferAdr	->	Decides usage of either buffer 1 or 2
    300          *					
    301          *	Purpose :		Enables continous write functionality to one of the dataflash buffers
    302          *					buffers. NOTE : User must ensure that CS goes high to terminate
    303          *					this mode before accessing other dataflash functionalities 
    304          *
    305          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    306          void Buffer_Write_Enable (unsigned char BufferNo, unsigned int IntPageAdr)
   \                     Buffer_Write_Enable:
    307          {
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   01C9               MOVW    R25:R24, R19:R18
    308          	DF_CS_inactive;								//make sure to toggle CS signal in order
   \   00000006   9A40               SBI     0x08, 0x00
    309          	DF_CS_active;								//to reset dataflash command decoder
   \   00000008   9840               CBI     0x08, 0x00
    310          	
    311          	if (1 == BufferNo)							//write enable to buffer 1
   \   0000000A   3001               CPI     R16, 1
   \   0000000C   F449               BRNE    ??Buffer_Write_Enable_0
    312          	{
    313          		DF_SPI_RW(Buf1Write);					//buffer 1 write op-code
   \   0000000E   E804               LDI     R16, 132
   \   00000010   ....               RCALL   DF_SPI_RW
    314          		DF_SPI_RW(0x00);						//don't cares
   \   00000012   E000               LDI     R16, 0
   \   00000014   ....               RCALL   DF_SPI_RW
    315          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
   \   00000016   018C               MOVW    R17:R16, R25:R24
   \   00000018   2F01               MOV     R16, R17
   \   0000001A   ....               RCALL   DF_SPI_RW
    316          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
   \   0000001C   2F08               MOV     R16, R24
   \   0000001E   ....               RCALL   DF_SPI_RW
    317          	}
    318          	
    319          #ifdef USE_BUFFER2
    320          	else
    321          	if (2 == BufferNo)							//write enable to buffer 2
    322          	{
    323          		DF_SPI_RW(Buf2Write);					//buffer 2 write op-code
    324          		DF_SPI_RW(0x00);						//don't cares
    325          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    326          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    327          	}
    328          #endif
    329          }
   \                     ??Buffer_Write_Enable_0:
   \   00000020   9189               LD      R24, Y+
   \   00000022   9199               LD      R25, Y+
   \   00000024   9508               RET
   \   00000026                      REQUIRE _A_PORTC
    330          
    331          
    332          
    333          /*****************************************************************************
    334          *
    335          *	Function name : Buffer_Write_Byte
    336          *
    337          *	Returns :		None
    338          *
    339          *	Parameters :	IntPageAdr	->	Internal page address to write byte to
    340          *					BufferAdr	->	Decides usage of either buffer 1 or 2
    341          *					Data		->	Data byte to be written
    342          *
    343          *	Purpose :		Writes one byte to one of the dataflash
    344          *					internal SRAM buffers
    345          *
    346          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    347          void Buffer_Write_Byte (unsigned char BufferNo, unsigned int IntPageAdr, unsigned char Data)
   \                     Buffer_Write_Byte:
    348          {
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   01C9               MOVW    R25:R24, R19:R18
   \   00000006   2FA1               MOV     R26, R17
    349          	
    350          	DF_CS_inactive;								//make sure to toggle CS signal in order
   \   00000008   9A40               SBI     0x08, 0x00
    351          	DF_CS_active;								//to reset dataflash command decoder
   \   0000000A   9840               CBI     0x08, 0x00
    352          	
    353          	if (1 == BufferNo)							//write byte to buffer 1
   \   0000000C   3001               CPI     R16, 1
   \   0000000E   F459               BRNE    ??Buffer_Write_Byte_0
    354          	{
    355          		DF_SPI_RW(Buf1Write);					//buffer 1 write op-code
   \   00000010   E804               LDI     R16, 132
   \   00000012   ....               RCALL   DF_SPI_RW
    356          		DF_SPI_RW(0x00);						//don't cares
   \   00000014   E000               LDI     R16, 0
   \   00000016   ....               RCALL   DF_SPI_RW
    357          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
   \   00000018   018C               MOVW    R17:R16, R25:R24
   \   0000001A   2F01               MOV     R16, R17
   \   0000001C   ....               RCALL   DF_SPI_RW
    358          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
   \   0000001E   2F08               MOV     R16, R24
   \   00000020   ....               RCALL   DF_SPI_RW
    359          		DF_SPI_RW(Data);						//write data byte
   \   00000022   2F0A               MOV     R16, R26
   \   00000024   ....               RCALL   DF_SPI_RW
    360          	}
    361          
    362          #ifdef USE_BUFFER2
    363          	else
    364          	if (2 == BufferNo)							//write byte to buffer 2
    365          	{
    366          		DF_SPI_RW(Buf2Write);					//buffer 2 write op-code
    367          		DF_SPI_RW(0x00);						//don't cares
    368          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    369          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    370          		DF_SPI_RW(Data);						//write data byte
    371          	}		
    372          #endif
    373          }
   \                     ??Buffer_Write_Byte_0:
   \   00000026   E0E3               LDI     R30, 3
   \   00000028   ........           JMP     ?EPILOGUE_B3_L09
   \   0000002C                      REQUIRE _A_PORTC
    374          
    375          
    376          /*****************************************************************************
    377          *
    378          *	Function name : Buffer_Write_Str
    379          *
    380          *	Returns :		None
    381          *
    382          *	Parameters :	BufferNo	->	Decides usage of either buffer 1 or 2
    383          *					IntPageAdr	->	Internal page address
    384          *					No_of_bytes	->	Number of bytes to be written
    385          *					*BufferPtr	->	address of buffer to be used for copy of bytes
    386          *									from AVR buffer to dataflash buffer 1 (or 2)
    387          *
    388          *	Purpose :		Copies one or more bytes to one of the dataflash
    389          *					internal SRAM buffers from AVR SRAM buffer
    390          *					pointed to by *BufferPtr
    391          *
    392          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    393          void Buffer_Write_Str (unsigned char BufferNo, unsigned int IntPageAdr, unsigned int No_of_bytes, unsigned char *BufferPtr)
   \                     Buffer_Write_Str:
    394          {
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   01D9               MOVW    R27:R26, R19:R18
   \   00000006   012A               MOVW    R5:R4, R21:R20
   \   00000008   01CB               MOVW    R25:R24, R23:R22
    395          	unsigned int i;
    396          
    397          	DF_CS_inactive;								//make sure to toggle CS signal in order
   \   0000000A   9A40               SBI     0x08, 0x00
    398          	DF_CS_active;								//to reset dataflash command decoder
   \   0000000C   9840               CBI     0x08, 0x00
    399          	
    400          	if (1 == BufferNo)							//write byte(s) to buffer 1
   \   0000000E   3001               CPI     R16, 1
   \   00000010   F4A1               BRNE    ??Buffer_Write_Str_0
    401          	{
    402          		DF_SPI_RW(Buf1Write);					//buffer 1 write op-code
   \   00000012   E804               LDI     R16, 132
   \   00000014   ....               RCALL   DF_SPI_RW
    403          		DF_SPI_RW(0x00);						//don't cares
   \   00000016   E000               LDI     R16, 0
   \   00000018   ....               RCALL   DF_SPI_RW
    404          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
   \   0000001A   018D               MOVW    R17:R16, R27:R26
   \   0000001C   2F01               MOV     R16, R17
   \   0000001E   ....               RCALL   DF_SPI_RW
    405          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
   \   00000020   2F0A               MOV     R16, R26
   \   00000022   ....               RCALL   DF_SPI_RW
    406          		for( i=0; i<No_of_bytes; i++)
   \   00000024   E0A0               LDI     R26, 0
   \   00000026   E0B0               LDI     R27, 0
   \   00000028   C005               RJMP    ??Buffer_Write_Str_1
    407          		{
    408          			DF_SPI_RW(*(BufferPtr));			//write byte pointed at by *BufferPtr to dataflash buffer 1 location
   \                     ??Buffer_Write_Str_2:
   \   0000002A   01FC               MOVW    R31:R30, R25:R24
   \   0000002C   9101               LD      R16, Z+
   \   0000002E   01CF               MOVW    R25:R24, R31:R30
   \   00000030   ....               RCALL   DF_SPI_RW
    409          			BufferPtr++;						//point to next element in AVR buffer
    410          		}
   \   00000032   9611               ADIW    R27:R26, 1
   \                     ??Buffer_Write_Str_1:
   \   00000034   15A4               CP      R26, R4
   \   00000036   05B5               CPC     R27, R5
   \   00000038   F3C0               BRCS    ??Buffer_Write_Str_2
    411          	}
    412          
    413          #ifdef USE_BUFFER2
    414          	else
    415          	if (2 == BufferNo)							//write byte(s) to buffer 2
    416          	{
    417          		DF_SPI_RW(Buf2Write);					//buffer 2 write op-code
    418          		DF_SPI_RW(0x00);						//don't cares
    419          		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    420          		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    421          		for( i=0; i<No_of_bytes; i++)
    422          		{
    423          			DF_SPI_RW(*(BufferPtr));			//write byte pointed at by *BufferPtr to dataflash buffer 2 location
    424          			BufferPtr++;						//point to next element in AVR buffer
    425          		}
    426          	}
    427          #endif
    428          }
   \                     ??Buffer_Write_Str_0:
   \   0000003A   E0E6               LDI     R30, 6
   \   0000003C   ........           JMP     ?EPILOGUE_B6_L09
   \   00000040                      REQUIRE _A_PORTC
    429          //NB : Monitorer busy-flag i status-reg.
    430          //NB : Sjekk at (IntAdr + No_of_bytes) < buffersize, hvis ikke blir det bare ball..
    431          
    432          
    433          
    434          /*****************************************************************************
    435          *
    436          *	Function name : Buffer_To_Page
    437          *
    438          *	Returns :		None
    439          *
    440          *	Parameters :	BufferAdr	->	Decides usage of either buffer 1 or 2
    441          *					PageAdr		->	Address of flash page to be programmed
    442          *
    443          *	Purpose :		Transfers a page from dataflash SRAM buffer to flash
    444          *					
    445          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    446          void Buffer_To_Page (unsigned char BufferNo, unsigned int PageAdr)
   \                     Buffer_To_Page:
    447          {
   \   00000000   ........           CALL    ?PROLOGUE3_L09
   \   00000004   01C9               MOVW    R25:R24, R19:R18
    448          	DF_CS_inactive;												//make sure to toggle CS signal in order
   \   00000006   9A40               SBI     0x08, 0x00
    449          	DF_CS_active;												//to reset dataflash command decoder
   \   00000008   9840               CBI     0x08, 0x00
    450          		
    451          	if (1 == BufferNo)											//program flash page from buffer 1
   \   0000000A   3001               CPI     R16, 1
   \   0000000C   F491               BRNE    ??Buffer_To_Page_0
    452          	{
    453          		DF_SPI_RW(Buf1ToFlashWE);								//buffer 1 to flash with erase op-code
   \   0000000E   E803               LDI     R16, 131
   \   00000010   ....               RCALL   DF_SPI_RW
    454          		DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));	//upper part of page address
   \   00000012   91A0....           LDS     R26, (PageSize + 2)
   \   00000016   E140               LDI     R20, 16
   \   00000018   1B4A               SUB     R20, R26
   \   0000001A   018C               MOVW    R17:R16, R25:R24
   \   0000001C   ........           CALL    ?US_SHR_L02
   \   00000020   ....               RCALL   DF_SPI_RW
    455          		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
   \   00000022   50A8               SUBI    R26, 8
   \   00000024   2F4A               MOV     R20, R26
   \   00000026   018C               MOVW    R17:R16, R25:R24
   \   00000028   ........           CALL    ?S_SHL_L02
   \   0000002C   ....               RCALL   DF_SPI_RW
    456          		DF_SPI_RW(0x00);										//don't cares
   \   0000002E   E000               LDI     R16, 0
   \   00000030   ....               RCALL   DF_SPI_RW
    457          	}
    458          
    459          #ifdef USE_BUFFER2
    460          	else	
    461          	if (2 == BufferNo)											//program flash page from buffer 2
    462          	{
    463          		DF_SPI_RW(Buf2ToFlashWE);								//buffer 2 to flash with erase op-code
    464          		DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));	//upper part of page address
    465          		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
    466          		DF_SPI_RW(0x00);										//don't cares
    467          	}
    468          #endif
    469          	
    470          	DF_CS_inactive;												//initiate flash page programming
   \                     ??Buffer_To_Page_0:
   \   00000032   9A40               SBI     0x08, 0x00
    471          	DF_CS_active;												
   \   00000034   9840               CBI     0x08, 0x00
    472          	
    473          	while(!(Read_DF_status() & 0x80));							//monitor the status register, wait until busy-flag is high
   \                     ??Buffer_To_Page_1:
   \   00000036   ....               RCALL   Read_DF_status
   \   00000038   FB07               BST     R16, 7
   \   0000003A   F7EE               BRTC    ??Buffer_To_Page_1
    474          }
   \   0000003C   E0E3               LDI     R30, 3
   \   0000003E   ........           JMP     ?EPILOGUE_B3_L09
   \   00000042                      REQUIRE _A_PORTC
    475          
    476          
    477          /*****************************************************************************
    478          *
    479          *	Function name : Cont_Flash_Read_Enable
    480          *
    481          *	Returns :		None
    482          *
    483          *	Parameters :	PageAdr		->	Address of flash page where cont.read starts from
    484          *					IntPageAdr	->	Internal page address where cont.read starts from
    485          *
    486          *	Purpose :		Initiates a continuous read from a location in the DataFlash
    487          *					
    488          ******************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    489          void Cont_Flash_Read_Enable (unsigned int PageAdr, unsigned int IntPageAdr)
   \                     Cont_Flash_Read_Enable:
    490          {
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   0128               MOVW    R5:R4, R17:R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    491          	DF_CS_inactive;																//make sure to toggle CS signal in order
   \   00000008   9A40               SBI     0x08, 0x00
    492          	DF_CS_active;																//to reset dataflash command decoder
   \   0000000A   9840               CBI     0x08, 0x00
    493          	
    494          	DF_SPI_RW(ContArrayRead);													//Continuous Array Read op-code
   \   0000000C   E608               LDI     R16, 104
   \   0000000E   ....               RCALL   DF_SPI_RW
    495          	DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));						//upper part of page address
   \   00000010   91A0....           LDS     R26, (PageSize + 2)
   \   00000014   E140               LDI     R20, 16
   \   00000016   1B4A               SUB     R20, R26
   \   00000018   0182               MOVW    R17:R16, R5:R4
   \   0000001A   ........           CALL    ?US_SHR_L02
   \   0000001E   ....               RCALL   DF_SPI_RW
    496          	DF_SPI_RW((unsigned char)((PageAdr << (PageBits - 8))+ (IntPageAdr>>8)));	//lower part of page address and MSB of int.page adr.
   \   00000020   50A8               SUBI    R26, 8
   \   00000022   2F4A               MOV     R20, R26
   \   00000024   0182               MOVW    R17:R16, R5:R4
   \   00000026   ........           CALL    ?S_SHL_L02
   \   0000002A   019C               MOVW    R19:R18, R25:R24
   \   0000002C   2F23               MOV     R18, R19
   \   0000002E   0F02               ADD     R16, R18
   \   00000030   ....               RCALL   DF_SPI_RW
    497          	DF_SPI_RW((unsigned char)(IntPageAdr));										//LSB byte of internal page address
   \   00000032   2F08               MOV     R16, R24
   \   00000034   ....               RCALL   DF_SPI_RW
    498          	DF_SPI_RW(0x00);															//perform 4 dummy writes
   \   00000036   E000               LDI     R16, 0
   \   00000038   ....               RCALL   DF_SPI_RW
    499          	DF_SPI_RW(0x00);															//in order to intiate DataFlash
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   ....               RCALL   DF_SPI_RW
    500          	DF_SPI_RW(0x00);															//address pointers
   \   0000003E   E000               LDI     R16, 0
   \   00000040   ....               RCALL   DF_SPI_RW
    501          	DF_SPI_RW(0x00);
   \   00000042   E000               LDI     R16, 0
   \   00000044   ....               RCALL   DF_SPI_RW
    502          }
   \   00000046   E0E6               LDI     R30, 6
   \   00000048   ........           JMP     ?EPILOGUE_B6_L09
   \   0000004C                      REQUIRE _A_PORTC
    503          
    504          // *****************************[ End Of DATAFLASH.C ]*************************
    505          

   \                                 In  segment CODE, align 2, keep-with-next
    506          void dataflash_test(void)
   \                     dataflash_test:
    507          {
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
    508          	unsigned int j;
    509          	
    510          	DF_CS_inactive;
   \   00000004   9A40               SBI     0x08, 0x00
    511          	DF_CS_active;  
   \   00000006   9840               CBI     0x08, 0x00
    512          	
    513          	//for(j=0;j<256;j++)
    514          		//Buffer_Write_Byte (1,j,0xA0);
    515          			
    516          	//Buffer_To_Page (1,0);             //transfer to DataFlash
    517          	Cont_Flash_Read_Enable (0,0);
   \   00000008   E020               LDI     R18, 0
   \   0000000A   E030               LDI     R19, 0
   \   0000000C   E000               LDI     R16, 0
   \   0000000E   E010               LDI     R17, 0
   \   00000010   ....               RCALL   Cont_Flash_Read_Enable
    518          	
    519          	for (j=0;j<256;j++)
   \   00000012   E080               LDI     R24, 0
   \   00000014   E090               LDI     R25, 0
   \   00000016   C007               RJMP    ??dataflash_test_0
    520          	{
    521          		g_page_buffer[j] = DF_SPI_RW(0x00);
   \                     ??dataflash_test_1:
   \   00000018   E000               LDI     R16, 0
   \   0000001A   ....               RCALL   DF_SPI_RW
   \   0000001C   01FC               MOVW    R31:R30, R25:R24
   \   0000001E   ....               SUBI    R30, LOW((-(g_page_buffer) & 0xFFFF))
   \   00000020   ....               SBCI    R31, (-(g_page_buffer) & 0xFFFF) >> 8
   \   00000022   8300               ST      Z, R16
    522          	}
   \   00000024   9601               ADIW    R25:R24, 1
   \                     ??dataflash_test_0:
   \   00000026   3080               CPI     R24, 0
   \   00000028   E001               LDI     R16, 1
   \   0000002A   0790               CPC     R25, R16
   \   0000002C   F3A8               BRCS    ??dataflash_test_1
    523          	
    524          	
    525          	for(j=0;j<256;j++)
   \   0000002E   E080               LDI     R24, 0
   \   00000030   E090               LDI     R25, 0
   \   00000032   C008               RJMP    ??dataflash_test_2
    526          	{
    527          			
    528          			if(j != DF_SPI_RW(0x00) )
   \                     ??dataflash_test_3:
   \   00000034   E000               LDI     R16, 0
   \   00000036   ....               RCALL   DF_SPI_RW
   \   00000038   E010               LDI     R17, 0
   \   0000003A   1780               CP      R24, R16
   \   0000003C   0791               CPC     R25, R17
   \   0000003E   F009               BREQ    ??dataflash_test_4
    529          			{
    530          				asm("nop");       
   \   00000040   0000               nop
    531          			}
    532          	}
   \                     ??dataflash_test_4:
   \   00000042   9601               ADIW    R25:R24, 1
   \                     ??dataflash_test_2:
   \   00000044   3080               CPI     R24, 0
   \   00000046   E001               LDI     R16, 1
   \   00000048   0790               CPC     R25, R16
   \   0000004A   F3A0               BRCS    ??dataflash_test_3
    533          	
    534          	DF_CS_inactive;  
   \   0000004C   9A40               SBI     0x08, 0x00
    535          }
   \   0000004E   9189               LD      R24, Y+
   \   00000050   9199               LD      R25, Y+
   \   00000052   9508               RET
   \   00000054                      REQUIRE _A_PORTC

   Maximum stack usage in bytes:

     Function                    CSTACK RSTACK
     --------                    ------ ------
     Buffer_Read_Byte                2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
     Buffer_Read_Str                 6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
     Buffer_To_Page                  3      4
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
       -> Read_DF_status             3      2
     Buffer_Write_Byte               3      2
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
       -> DF_SPI_RW                  3      2
     Buffer_Write_Enable             2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2
     Buffer_Write_Str                6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
     Cont_Flash_Read_Enable          6      4
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
       -> DF_SPI_RW                  6      2
     DF_SPI_RW                       0      2
     DF_SPI_disable                  0      2
     DF_SPI_init                     0      2
     Page_To_Buffer                  4      4
       -> DF_SPI_RW                  4      2
       -> DF_SPI_RW                  4      2
       -> DF_SPI_RW                  4      2
       -> DF_SPI_RW                  4      2
       -> Read_DF_status             4      2
     Read_DF_status                  0      2
       -> DF_SPI_RW                  0      2
       -> DF_SPI_RW                  0      2
     dataflash_test                  2      2
       -> Cont_Flash_Read_Enable     2      2
       -> DF_SPI_RW                  2      2
       -> DF_SPI_RW                  2      2


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_SPDR                   1
     _A_SPSR                   1
     _A_SPCR                   1
     _A_PORTC                  1
     _A_DDRC                   1
     _A_PORTB                  1
     _A_DDRB                   1
     DF_pagesize              24
     DF_pagebits
     PageSize                  3
     PageBits
     DF_SPI_init              30
     DF_SPI_disable            8
     DF_SPI_RW                14
     Read_DF_status           60
     Page_To_Buffer           66
     Buffer_Read_Byte         50
     Buffer_Read_Str          70
     Buffer_Write_Enable      38
     Buffer_Write_Byte        44
     Buffer_Write_Str         64
     Buffer_To_Page           66
     Cont_Flash_Read_Enable   76
     dataflash_test           84
      Others                   6

 
   7 bytes in segment ABSOLUTE
 670 bytes in segment CODE
   6 bytes in segment INITTAB
  24 bytes in segment NEAR_F
   3 bytes in segment NEAR_Z
 
 694 bytes of CODE memory (+ 6 bytes shared)
   3 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
